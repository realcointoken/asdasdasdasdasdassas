{
  "address": "0x541f3D4cA30B4C5162eb1C3A39e138f72219EdC1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_mirrorDomain",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_amb",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_rootManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_mirrorConnector",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasCap",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Connector__processMessage_notUsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyOwner_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyProposed_notProposedOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__ownershipDelayElapsed_delayNotElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_noOwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_noProposal",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_updated",
          "type": "uint256"
        }
      ],
      "name": "GasCapUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MessageProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "encodedData",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MessageSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previous",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "current",
          "type": "address"
        }
      ],
      "name": "MirrorConnectorUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "mirrorDomain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "amb",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "rootManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "mirrorConnector",
          "type": "address"
        }
      ],
      "name": "NewConnector",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposedOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "AMB",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DOMAIN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIRROR_DOMAIN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_MANAGER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptProposedOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mirrorConnector",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "processMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_l2BlockNumber",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_l2MessageIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "_l2TxNumberInBlock",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "bytes32[]",
          "name": "_proof",
          "type": "bytes32[]"
        }
      ],
      "name": "processMessageFromRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "processed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newlyProposed",
          "type": "address"
        }
      ],
      "name": "proposeNewOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposed",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounced",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_encodedData",
          "type": "bytes"
        }
      ],
      "name": "sendMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasCap",
          "type": "uint256"
        }
      ],
      "name": "setGasCap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_mirrorConnector",
          "type": "address"
        }
      ],
      "name": "setMirrorConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_expected",
          "type": "address"
        }
      ],
      "name": "verifySender",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x64408605ee5f954d21f97382ac83b182b54db7c58d6996e7cb6f39193e390ef6",
  "receipt": {
    "to": null,
    "from": "0x54BAA998771639628ffC0206c3b916c466b79c89",
    "contractAddress": "0x541f3D4cA30B4C5162eb1C3A39e138f72219EdC1",
    "transactionIndex": 411,
    "gasUsed": "1229622",
    "logsBloom": "0x00800000020000000000000000000001000010000000001000800000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000000000000000000000000000000000010020000000000000000000800000000000010000000000000000000400000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000008000000000000010000000000000000000000080000000020000000000000000000000000040000000000000000040002000000040000000000",
    "blockHash": "0x5f832401d9f9fcd4da79caab3c444eb5d8dbbc01449b4f91c82f7e39339e7453",
    "transactionHash": "0x64408605ee5f954d21f97382ac83b182b54db7c58d6996e7cb6f39193e390ef6",
    "logs": [
      {
        "transactionIndex": 411,
        "blockNumber": 8531169,
        "transactionHash": "0x64408605ee5f954d21f97382ac83b182b54db7c58d6996e7cb6f39193e390ef6",
        "address": "0x541f3D4cA30B4C5162eb1C3A39e138f72219EdC1",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000054baa998771639628ffc0206c3b916c466b79c89"
        ],
        "data": "0x",
        "logIndex": 93,
        "blockHash": "0x5f832401d9f9fcd4da79caab3c444eb5d8dbbc01449b4f91c82f7e39339e7453"
      },
      {
        "transactionIndex": 411,
        "blockNumber": 8531169,
        "transactionHash": "0x64408605ee5f954d21f97382ac83b182b54db7c58d6996e7cb6f39193e390ef6",
        "address": "0x541f3D4cA30B4C5162eb1C3A39e138f72219EdC1",
        "topics": [
          "0x4f9c27c2fe3f84576ea469d367d044da53c45e951617e8389f2b5ed8db9d25f0",
          "0x00000000000000000000000000000000000000000000000000000000676f6572",
          "0x000000000000000000000000000000000000000000000000000000007a6b7374"
        ],
        "data": "0x0000000000000000000000001908e2bf4a88f91e4ef0dc72f02b8ea36bea23190000000000000000000000000310db8043520bf31fbef5350d1e3d451c6de68a0000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 94,
        "blockHash": "0x5f832401d9f9fcd4da79caab3c444eb5d8dbbc01449b4f91c82f7e39339e7453"
      },
      {
        "transactionIndex": 411,
        "blockNumber": 8531169,
        "transactionHash": "0x64408605ee5f954d21f97382ac83b182b54db7c58d6996e7cb6f39193e390ef6",
        "address": "0x541f3D4cA30B4C5162eb1C3A39e138f72219EdC1",
        "topics": [
          "0x877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cf850",
        "logIndex": 95,
        "blockHash": "0x5f832401d9f9fcd4da79caab3c444eb5d8dbbc01449b4f91c82f7e39339e7453"
      }
    ],
    "blockNumber": 8531169,
    "cumulativeGasUsed": "21123582",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "1735353714",
    "2053862260",
    "0x1908e2BF4a88F91E4eF0DC72f02b8Ea36BEa2319",
    "0x0310DB8043520BF31fBEf5350D1E3d451C6de68a",
    "0x0000000000000000000000000000000000000000",
    "850000"
  ],
  "numDeployments": 1,
  "solcInputHash": "411f61b7b22cb939cc836a40e733cf61",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_mirrorDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_amb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mirrorConnector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasCap\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Connector__processMessage_notUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyOwner_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyProposed_notProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__ownershipDelayElapsed_delayNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_noOwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_noProposal\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_updated\",\"type\":\"uint256\"}],\"name\":\"GasCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MessageProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"MirrorConnectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"mirrorDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"amb\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rootManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mirrorConnector\",\"type\":\"address\"}],\"name\":\"NewConnector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIRROR_DOMAIN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_MANAGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptProposedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"processMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_l2BlockNumber\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_l2TxNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"processMessageFromRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newlyProposed\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_encodedData\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasCap\",\"type\":\"uint256\"}],\"name\":\"setGasCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mirrorConnector\",\"type\":\"address\"}],\"name\":\"setMirrorConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_expected\",\"type\":\"address\"}],\"name\":\"verifySender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"processMessage(bytes)\":{\"details\":\"This is called by AMBs to process messages originating from mirror connector\"},\"processMessageFromRoot(uint32,uint256,uint16,bytes,bytes32[])\":{\"details\":\"modified from: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\"},\"sendMessage(bytes,bytes)\":{\"details\":\"This is called by the root manager *only* on mainnet to propagate the aggregate root\"}},\"version\":1},\"userdoc\":{\"events\":{\"GasCapUpdated(uint256,uint256)\":{\"notice\":\"Emitted when admin updates the gas cap\"},\"MessageProcessed(bytes,address)\":{\"notice\":\"Emitted whenever a message is successfully received over an AMB\"},\"MessageSent(bytes,bytes,address)\":{\"notice\":\"Emitted whenever a message is successfully sent over an AMB\"}},\"kind\":\"user\",\"methods\":{\"AMB()\":{\"notice\":\"Address of the AMB on this domain.\"},\"DOMAIN()\":{\"notice\":\"The domain of this Messaging (i.e. Connector) contract.\"},\"MIRROR_DOMAIN()\":{\"notice\":\"The domain of the corresponding messaging (i.e. Connector) contract.\"},\"ROOT_MANAGER()\":{\"notice\":\"RootManager contract address.\"},\"acceptProposedOwner()\":{\"notice\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"delay()\":{\"notice\":\"Returns the delay period before a new owner can be accepted.\"},\"mirrorConnector()\":{\"notice\":\"Connector on L2 for L1 connectors, and vice versa.\"},\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"processMessage(bytes)\":{\"notice\":\"Processes a message received by an AMB\"},\"processMessageFromRoot(uint32,uint256,uint16,bytes,bytes32[])\":{\"notice\":\"Processes message and proves inclusion of that message in the root.\"},\"proposeNewOwner(address)\":{\"notice\":\"Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process\"},\"proposed()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"proposedTimestamp()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"renounceOwnership()\":{\"notice\":\"Renounces ownership of the contract after a delay\"},\"renounced()\":{\"notice\":\"Indicates if the ownership has been renounced() by checking if current owner is address(0)\"},\"sendMessage(bytes,bytes)\":{\"notice\":\"Sends a message over the amb\"},\"setMirrorConnector(address)\":{\"notice\":\"Sets the address of the l2Connector for this domain\"},\"verifySender(address)\":{\"notice\":\"Checks the cross domain sender for a given address\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol\":\"ZkSyncHubConnector\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@matterlabs/zksync-contracts/l1/contracts/common/interfaces/IAllowList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAllowList {\\n    /*//////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice public access is changed\\n    event UpdatePublicAccess(address indexed target, bool newStatus);\\n\\n    /// @notice permission to call is changed\\n    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);\\n\\n    /// @notice pendingOwner is changed\\n    /// @dev Also emitted when the new owner is accepted and in this case, `newPendingOwner` would be zero address\\n    event NewPendingOwner(address indexed oldPendingOwner, address indexed newPendingOwner);\\n\\n    /// @notice Owner changed\\n    event NewOwner(address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function isAccessPublic(address _target) external view returns (bool);\\n\\n    function hasSpecialAccessToCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig\\n    ) external view returns (bool);\\n\\n    function canCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig\\n    ) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           ALLOW LIST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setBatchPublicAccess(address[] calldata _targets, bool[] calldata _enables) external;\\n\\n    function setPublicAccess(address _target, bool _enable) external;\\n\\n    function setBatchPermissionToCall(\\n        address[] calldata _callers,\\n        address[] calldata _targets,\\n        bytes4[] calldata _functionSigs,\\n        bool[] calldata _enables\\n    ) external;\\n\\n    function setPermissionToCall(\\n        address _caller,\\n        address _target,\\n        bytes4 _functionSig,\\n        bool _enable\\n    ) external;\\n\\n    function setPendingOwner(address _newPendingOwner) external;\\n\\n    function acceptOwner() external;\\n}\\n\",\"keccak256\":\"0x648fee7e23d2ca13481efc07902a38b817be7606bf288902d72f81a2cabcf2f5\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/common/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n * @dev Unlike EIP-20 standard \\\"transfer\\\" and \\\"transferFrom\\\" functions do not return any value.\\n * This is made to be compatible with popular tokens that are implemented standard incorrectly.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5bfbd33ae826ac8185db71bb348c91010938dbb2dd0859ce908f4812ff39d2fe\",\"license\":\"UNLICENSED\"},\"@matterlabs/zksync-contracts/l1/contracts/common/libraries/UncheckedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nlibrary UncheckedMath {\\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\\n        unchecked {\\n            return _number + 1;\\n        }\\n    }\\n\\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\\n        unchecked {\\n            return _lhs + _rhs;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d0dff9b45338f35b32bc711192aec50973e13dc74b8e941d64586b510179c12\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/Plonk4VerifierWithAccessToDNext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/PairingsBn254.sol\\\";\\nimport \\\"./libraries/TranscriptLib.sol\\\";\\nimport \\\"../common/libraries/UncheckedMath.sol\\\";\\n\\nuint256 constant STATE_WIDTH = 4;\\nuint256 constant NUM_G2_ELS = 2;\\n\\nstruct VerificationKey {\\n    uint256 domain_size;\\n    uint256 num_inputs;\\n    PairingsBn254.Fr omega;\\n    PairingsBn254.G1Point[2] gate_selectors_commitments;\\n    PairingsBn254.G1Point[7] gate_setup_commitments;\\n    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\\n    PairingsBn254.G1Point lookup_selector_commitment;\\n    PairingsBn254.G1Point[4] lookup_tables_commitments;\\n    PairingsBn254.G1Point lookup_table_type_commitment;\\n    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;\\n    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;\\n}\\n\\ncontract Plonk4VerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLib for TranscriptLib.Transcript;\\n\\n    using UncheckedMath for uint256;\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        // commitments\\n        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;\\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;\\n        // openings\\n        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;\\n        PairingsBn254.Fr[1] state_polys_openings_at_z_omega; // TODO: not use array while there is only D_next\\n        PairingsBn254.Fr[1] gate_selectors_openings_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;\\n        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;\\n        PairingsBn254.Fr quotient_poly_opening_at_z;\\n        PairingsBn254.Fr linearization_poly_opening_at_z;\\n        // lookup commitments\\n        PairingsBn254.G1Point lookup_s_poly_commitment;\\n        PairingsBn254.G1Point lookup_grand_product_commitment;\\n        // lookup openings\\n        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_t_poly_opening_at_z;\\n        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;\\n        PairingsBn254.Fr lookup_selector_poly_opening_at_z;\\n        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;\\n        PairingsBn254.G1Point opening_proof_at_z;\\n        PairingsBn254.G1Point opening_proof_at_z_omega;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr zero;\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr[9] alpha_values;\\n        PairingsBn254.Fr eta;\\n        PairingsBn254.Fr beta_lookup;\\n        PairingsBn254.Fr gamma_lookup;\\n        PairingsBn254.Fr beta_plus_one;\\n        PairingsBn254.Fr beta_gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr z_omega;\\n        PairingsBn254.Fr z_minus_last_omega;\\n        PairingsBn254.Fr l_0_at_z;\\n        PairingsBn254.Fr l_n_minus_one_at_z;\\n        PairingsBn254.Fr t;\\n        PairingsBn254.G1Point tp;\\n    }\\n\\n    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory num)\\n    {\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);\\n        PairingsBn254.Fr memory den = at.copy();\\n        den.sub_assign(one);\\n        den.mul_assign(size_fe);\\n\\n        den = den.inverse();\\n\\n        num = at.pow(domain_size);\\n        num.sub_assign(one);\\n        num.mul_assign(den);\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        // (omega^i / N) / (X - omega^i) * (X^N - 1)\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\\n        internal\\n        view\\n        returns (PairingsBn254.Fr memory res)\\n    {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function initialize_transcript(Proof memory proof, VerificationKey memory vk)\\n        internal\\n        pure\\n        returns (PartialVerifierState memory state)\\n    {\\n        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();\\n\\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            transcript.update_with_g1(proof.state_polys_commitments[i]);\\n        }\\n\\n        state.eta = transcript.get_challenge();\\n        transcript.update_with_g1(proof.lookup_s_poly_commitment);\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\\n        state.beta_lookup = transcript.get_challenge();\\n        state.gamma_lookup = transcript.get_challenge();\\n        transcript.update_with_g1(proof.lookup_grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);\\n        }\\n        state.z = transcript.get_challenge();\\n\\n        transcript.update_with_fr(proof.quotient_poly_opening_at_z);\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);\\n        }\\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);\\n        }\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);\\n        }\\n\\n        state.z_omega = state.z.copy();\\n        state.z_omega.mul_assign(vk.omega);\\n\\n        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);\\n\\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);\\n        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);\\n        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);\\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);\\n        transcript.update_with_fr(proof.linearization_poly_opening_at_z);\\n\\n        state.v = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.opening_proof_at_z);\\n        transcript.update_with_g1(proof.opening_proof_at_z_omega);\\n\\n        state.u = transcript.get_challenge();\\n    }\\n\\n    // compute some powers of challenge alpha([alpha^1, .. alpha^8])\\n    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {\\n        require(state.alpha.value != 0);\\n        state.alpha_values[0] = PairingsBn254.new_fr(1);\\n        state.alpha_values[1] = state.alpha.copy();\\n        PairingsBn254.Fr memory current_alpha = state.alpha.copy();\\n        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {\\n            current_alpha.mul_assign(state.alpha);\\n            state.alpha_values[i] = current_alpha.copy();\\n        }\\n    }\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        // we initialize all challenges beforehand, we can draw each challenge in its own place\\n        PartialVerifierState memory state = initialize_transcript(proof, vk);\\n        if (verify_quotient_evaluation(vk, proof, state) == false) {\\n            return false;\\n        }\\n        require(proof.state_polys_openings_at_z_omega.length == 1); // TODO\\n\\n        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();\\n        {\\n            // block scope\\n            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();\\n            PairingsBn254.G1Point memory tp;\\n            // start from i =1\\n            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n                tp = proof.quotient_poly_parts_commitments[i].copy_g1();\\n                tp.point_mul_assign(current_z);\\n                quotient_result.point_add_assign(tp);\\n\\n                current_z.mul_assign(z_in_domain_size);\\n            }\\n        }\\n\\n        Queries memory queries = prepare_queries(vk, proof, state);\\n        queries.commitments_at_z[0] = quotient_result;\\n        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;\\n        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);\\n        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;\\n\\n        require(queries.commitments_at_z.length == queries.values_at_z.length);\\n\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];\\n\\n        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.G1Point memory scaled;\\n        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {\\n            aggregation_challenge.mul_assign(state.v);\\n            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);\\n            aggregated_commitment_at_z.point_add_assign(scaled);\\n\\n            state.t = queries.values_at_z[i];\\n            state.t.mul_assign(aggregation_challenge);\\n            aggregated_opening_at_z.add_assign(state.t);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(\\n            aggregation_challenge\\n        );\\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];\\n        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);\\n        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);\\n            aggregated_commitment_at_z_omega.point_add_assign(scaled);\\n\\n            state.t = queries.values_at_z_omega[i];\\n            state.t.mul_assign(aggregation_challenge);\\n            aggregated_opening_at_z_omega.add_assign(state.t);\\n        }\\n\\n        return\\n            final_pairing(\\n                vk.g2_elements,\\n                proof,\\n                state,\\n                aggregated_commitment_at_z,\\n                aggregated_commitment_at_z_omega,\\n                aggregated_opening_at_z,\\n                aggregated_opening_at_z_omega\\n            );\\n    }\\n\\n    function verify_quotient_evaluation(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (bool) {\\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {\\n            lagrange_poly_numbers[i] = i;\\n        }\\n        // require(vk.num_inputs > 0); // TODO\\n\\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\\n            // TODO we may use batched lagrange compputation\\n            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);\\n            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            inputs_term.add_assign(state.t);\\n        }\\n        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);\\n        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();\\n        result.add_assign(inputs_term);\\n\\n        // compute powers of alpha\\n        compute_powers_of_alpha(state);\\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\\n\\n        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\\n        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);\\n        PairingsBn254.Fr memory t; // TMP;\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\\n            t.mul_assign(state.beta);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n            t.add_assign(state.gamma);\\n\\n            factor.mul_assign(t);\\n        }\\n\\n        t = proof.state_polys_openings_at_z[3].copy();\\n        t.add_assign(state.gamma);\\n        factor.mul_assign(t);\\n        result.sub_assign(factor);\\n\\n        // - L_0(z) * alpha_1\\n        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);\\n        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);\\n        result.sub_assign(l_0_at_z);\\n\\n        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);\\n        result.add_assign(lookup_quotient_contrib);\\n\\n        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();\\n        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));\\n        return lhs.value == result.value;\\n    }\\n\\n    function lookup_quotient_contribution(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (PairingsBn254.Fr memory result) {\\n        PairingsBn254.Fr memory t;\\n\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        state.beta_plus_one = state.beta_lookup.copy();\\n        state.beta_plus_one.add_assign(one);\\n        state.beta_gamma = state.beta_plus_one.copy();\\n        state.beta_gamma.mul_assign(state.gamma_lookup);\\n\\n        // (s'*beta + gamma)*(zw')*alpha\\n        t = proof.lookup_s_poly_opening_at_z_omega.copy();\\n        t.mul_assign(state.beta_lookup);\\n        t.add_assign(state.beta_gamma);\\n        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);\\n        t.mul_assign(state.alpha_values[6]);\\n\\n        // (z - omega^{n-1}) for this part\\n        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);\\n        state.z_minus_last_omega = state.z.copy();\\n        state.z_minus_last_omega.sub_assign(last_omega);\\n        t.mul_assign(state.z_minus_last_omega);\\n        result.add_assign(t);\\n\\n        // - alpha_1 * L_{0}(z)\\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\\n        t = state.l_0_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 1]);\\n        result.sub_assign(t);\\n\\n        // - alpha_2 * beta_gamma_powered L_{n-1}(z)\\n        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);\\n        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(\\n            vk.domain_size - 1,\\n            vk.domain_size,\\n            vk.omega,\\n            state.z\\n        );\\n        t = state.l_n_minus_one_at_z.copy();\\n        t.mul_assign(beta_gamma_powered);\\n        t.mul_assign(state.alpha_values[6 + 2]);\\n\\n        result.sub_assign(t);\\n    }\\n\\n    function aggregated_linearization_commitment(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) internal view returns (PairingsBn254.G1Point memory result) {\\n        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)\\n        result = PairingsBn254.new_g1(0, 0);\\n        // Q_a * A\\n        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(\\n            proof.state_polys_openings_at_z[0]\\n        );\\n        result.point_add_assign(scaled);\\n        // Q_b * B\\n        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);\\n        result.point_add_assign(scaled);\\n        // Q_c * C\\n        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);\\n        result.point_add_assign(scaled);\\n        // Q_d * D\\n        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);\\n        result.point_add_assign(scaled);\\n        // Q_m* A*B or Q_ab*A*B\\n        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();\\n        t.mul_assign(proof.state_polys_openings_at_z[1]);\\n        scaled = vk.gate_setup_commitments[4].point_mul(t);\\n        result.point_add_assign(scaled);\\n        // Q_const\\n        result.point_add_assign(vk.gate_setup_commitments[5]);\\n        // Q_dNext * D_next\\n        scaled = vk.gate_setup_commitments[6].point_mul(proof.state_polys_openings_at_z_omega[0]);\\n        result.point_add_assign(scaled);\\n        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);\\n\\n        PairingsBn254.G1Point\\n            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(\\n                vk,\\n                proof,\\n                state\\n            );\\n        result.point_add_assign(rescue_custom_gate_linearization_contrib);\\n        require(vk.non_residues.length == STATE_WIDTH - 1);\\n\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {\\n            t = state.z.copy();\\n            if (i == 0) {\\n                t.mul_assign(one);\\n            } else {\\n                t.mul_assign(vk.non_residues[i - 1]); // TODO add one into non-residues during codegen?\\n            }\\n            t.mul_assign(state.beta);\\n            t.add_assign(state.gamma);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n\\n            factor.mul_assign(t);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\\n        factor = state.alpha_values[4].copy();\\n        factor.mul_assign(state.beta);\\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\\n            t.mul_assign(state.beta);\\n            t.add_assign(state.gamma);\\n            t.add_assign(proof.state_polys_openings_at_z[i]);\\n\\n            factor.mul_assign(t);\\n        }\\n        scaled = vk.permutation_commitments[3].point_mul(factor);\\n        result.point_sub_assign(scaled);\\n\\n        // + L_0(z) * Z(x)\\n        // TODO\\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\\n        require(state.l_0_at_z.value != 0);\\n        factor = state.l_0_at_z.copy();\\n        factor.mul_assign(state.alpha_values[4 + 1]);\\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);\\n        result.point_add_assign(lookup_linearization_contrib);\\n    }\\n\\n    function rescue_custom_gate_linearization_contribution(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) public view returns (PairingsBn254.G1Point memory result) {\\n        PairingsBn254.Fr memory t;\\n        PairingsBn254.Fr memory intermediate_result;\\n\\n        // a^2 - b = 0\\n        t = proof.state_polys_openings_at_z[0].copy();\\n        t.mul_assign(t);\\n        t.sub_assign(proof.state_polys_openings_at_z[1]);\\n        // t.mul_assign(challenge1);\\n        t.mul_assign(state.alpha_values[1]);\\n        intermediate_result.add_assign(t);\\n\\n        // b^2 - c = 0\\n        t = proof.state_polys_openings_at_z[1].copy();\\n        t.mul_assign(t);\\n        t.sub_assign(proof.state_polys_openings_at_z[2]);\\n        t.mul_assign(state.alpha_values[1 + 1]);\\n        intermediate_result.add_assign(t);\\n\\n        // c*a - d = 0;\\n        t = proof.state_polys_openings_at_z[2].copy();\\n        t.mul_assign(proof.state_polys_openings_at_z[0]);\\n        t.sub_assign(proof.state_polys_openings_at_z[3]);\\n        t.mul_assign(state.alpha_values[1 + 2]);\\n        intermediate_result.add_assign(t);\\n\\n        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);\\n    }\\n\\n    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)\\n        internal\\n        view\\n        returns (PairingsBn254.G1Point memory result)\\n    {\\n        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);\\n\\n        PairingsBn254.Fr memory t;\\n        PairingsBn254.Fr memory factor;\\n        // s(x) from the Z(x*omega)*(\\\\gamma*(1 + \\\\beta) + s(x) + \\\\beta * s(x*omega)))\\n        factor = proof.lookup_grand_product_opening_at_z_omega.copy();\\n        factor.mul_assign(state.alpha_values[6]);\\n        factor.mul_assign(state.z_minus_last_omega);\\n\\n        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n\\n        // Z(x) from - alpha_0 * Z(x) * (\\\\beta + 1) * (\\\\gamma + f(x)) * (\\\\gamma(1 + \\\\beta) + t(x) + \\\\beta * t(x*omega))\\n        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\\n\\n        // accumulate coefficient\\n        factor = proof.lookup_t_poly_opening_at_z_omega.copy();\\n        factor.mul_assign(state.beta_lookup);\\n        factor.add_assign(proof.lookup_t_poly_opening_at_z);\\n        factor.add_assign(state.beta_gamma);\\n\\n        // (\\\\gamma + f(x))\\n        PairingsBn254.Fr memory f_reconstructed;\\n        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory tmp0;\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            tmp0 = proof.state_polys_openings_at_z[i].copy();\\n            tmp0.mul_assign(current);\\n            f_reconstructed.add_assign(tmp0);\\n\\n            current.mul_assign(state.eta);\\n        }\\n\\n        // add type of table\\n        t = proof.lookup_table_type_poly_opening_at_z.copy();\\n        t.mul_assign(current);\\n        f_reconstructed.add_assign(t);\\n\\n        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);\\n        f_reconstructed.add_assign(state.gamma_lookup);\\n\\n        // end of (\\\\gamma + f(x)) part\\n        factor.mul_assign(f_reconstructed);\\n        factor.mul_assign(state.beta_plus_one);\\n        t = zero.copy();\\n        t.sub_assign(factor);\\n        factor = t;\\n        factor.mul_assign(state.alpha_values[6]);\\n\\n        // Multiply by (z - omega^{n-1})\\n        factor.mul_assign(state.z_minus_last_omega);\\n\\n        // L_{0}(z) in front of Z(x)\\n        t = state.l_0_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 1]);\\n        factor.add_assign(t);\\n\\n        // L_{n-1}(z) in front of Z(x)\\n        t = state.l_n_minus_one_at_z.copy();\\n        t.mul_assign(state.alpha_values[6 + 2]);\\n        factor.add_assign(t);\\n\\n        scaled = proof.lookup_grand_product_commitment.point_mul(factor);\\n        result.point_add_assign(scaled);\\n    }\\n\\n    struct Queries {\\n        PairingsBn254.G1Point[13] commitments_at_z;\\n        PairingsBn254.Fr[13] values_at_z;\\n        PairingsBn254.G1Point[6] commitments_at_z_omega;\\n        PairingsBn254.Fr[6] values_at_z_omega;\\n    }\\n\\n    function prepare_queries(\\n        VerificationKey memory vk,\\n        Proof memory proof,\\n        PartialVerifierState memory state\\n    ) public view returns (Queries memory queries) {\\n        // we set first two items in calee side so start idx from 2\\n        uint256 idx = 2;\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];\\n            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];\\n            idx = idx.uncheckedInc();\\n        }\\n        require(proof.gate_selectors_openings_at_z.length == 1);\\n        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];\\n        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];\\n        idx = idx.uncheckedInc();\\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\\n            queries.commitments_at_z[idx] = vk.permutation_commitments[i];\\n            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];\\n            idx = idx.uncheckedInc();\\n        }\\n\\n        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;\\n        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];\\n\\n        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;\\n        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];\\n\\n        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];\\n        PairingsBn254.Fr memory current_eta = state.eta.copy();\\n        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {\\n            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);\\n            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);\\n\\n            current_eta.mul_assign(state.eta);\\n        }\\n        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;\\n        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;\\n        idx = idx.uncheckedInc();\\n        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;\\n        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;\\n        idx = idx.uncheckedInc();\\n        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;\\n        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;\\n        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;\\n        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;\\n        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;\\n        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;\\n        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;\\n        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;\\n    }\\n\\n    function final_pairing(\\n        // VerificationKey memory vk,\\n        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,\\n        Proof memory proof,\\n        PartialVerifierState memory state,\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z,\\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,\\n        PairingsBn254.Fr memory aggregated_opening_at_z,\\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega\\n    ) internal view returns (bool) {\\n        // q(x) = f(x) - f(z) / (x - z)\\n        // q(x) * (x-z)  = f(x) - f(z)\\n\\n        // f(x)\\n        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();\\n        aggregated_commitment_at_z_omega.point_mul_assign(state.u);\\n        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);\\n\\n        // - f(z)*g\\n        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();\\n        aggregated_value.mul_assign(state.u);\\n        aggregated_value.add_assign(aggregated_opening_at_z);\\n        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);\\n        pair_with_generator.point_sub_assign(tp);\\n\\n        // +z * q(x)\\n        tp = proof.opening_proof_at_z.point_mul(state.z);\\n        PairingsBn254.Fr memory t = state.z_omega.copy();\\n        t.mul_assign(state.u);\\n        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);\\n        tp.point_add_assign(t1);\\n        pair_with_generator.point_add_assign(tp);\\n\\n        // rhs\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_proof_at_z);\\n        pair_with_x.negate();\\n        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`\\n        // so we handle it in code generation step\\n        PairingsBn254.G2Point memory first_g2 = g2_elements[0];\\n        PairingsBn254.G2Point memory second_g2 = g2_elements[1];\\n        PairingsBn254.G2Point memory gen2 = PairingsBn254.P2();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);\\n    }\\n}\\n\",\"keccak256\":\"0x3ef4937c0ab65a60baabb5b00ece282148267f94bc6c087254faf925c2bdc7d2\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Verifier.sol\\\";\\nimport \\\"../common/interfaces/IAllowList.sol\\\";\\nimport \\\"./libraries/PriorityQueue.sol\\\";\\n\\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\\n/// @param proposedDiamondCutHash The hash of diamond cut that was proposed in the current upgrade\\n/// @param proposedDiamondCutTimestamp The timestamp when the diamond cut was proposed, zero if there are no active proposals\\n/// @param lastDiamondFreezeTimestamp The timestamp when the diamond was frozen last time, zero if the diamond was never frozen\\n/// @param currentProposalId The serial number of proposed diamond cuts, increments when proposing a new diamond cut\\n/// @param securityCouncilMembers The set of the trusted\\u00a0addresses that can instantly finish upgrade (diamond cut)\\n/// @param securityCouncilMemberLastApprovedProposalId The mapping of the security council addresses and the last diamond cut that they approved\\n/// @param securityCouncilEmergencyApprovals The number of received upgrade approvals from the security council\\nstruct DiamondCutStorage {\\n    bytes32 proposedDiamondCutHash;\\n    uint256 proposedDiamondCutTimestamp;\\n    uint256 lastDiamondFreezeTimestamp;\\n    uint256 currentProposalId;\\n    mapping(address => bool) securityCouncilMembers;\\n    mapping(address => uint256) securityCouncilMemberLastApprovedProposalId;\\n    uint256 securityCouncilEmergencyApprovals;\\n}\\n\\n/// @dev The log passed from L2\\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\\n/// This field is required formally but does not have any special meaning.\\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\\n/// @param sender The L2 address which sent the log\\n/// @param key The 32 bytes of information that was sent in the log\\n/// @param value The 32 bytes of information that was sent in the log\\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\\nstruct L2Log {\\n    uint8 l2ShardId;\\n    bool isService;\\n    uint16 txNumberInBlock;\\n    address sender;\\n    bytes32 key;\\n    bytes32 value;\\n}\\n\\n/// @dev An arbitrary length message passed from L2\\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\\n/// @param sender The address of the L2 account from which the message was passed\\n/// @param data An arbitrary length message\\nstruct L2Message {\\n    uint16 txNumberInBlock;\\n    address sender;\\n    bytes data;\\n}\\n\\n/// @notice Part of the configuration parameters of ZKP circuits\\nstruct VerifierParams {\\n    bytes32 recursionNodeLevelVkHash;\\n    bytes32 recursionLeafLevelVkHash;\\n    bytes32 recursionCircuitsSetVksHash;\\n}\\n\\n/// @dev storing all storage variables for zkSync facets\\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\\n/// NOTE: but NOT to modify already existing variables or change their order\\nstruct AppStorage {\\n    /// @dev Storage of variables needed for diamond cut facet\\n    DiamondCutStorage diamondCutStorage;\\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\\n    address governor;\\n    /// @notice Address that governor proposed as one that will replace it\\n    address pendingGovernor;\\n    /// @notice List of permitted validators\\n    mapping(address => bool) validators;\\n    // TODO: should be used an external library approach\\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\\n    Verifier verifier;\\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\\n    uint256 totalBlocksExecuted;\\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\\n    uint256 totalBlocksVerified;\\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\\n    uint256 totalBlocksCommitted;\\n    /// @dev Stored hashed StoredBlock for block number\\n    mapping(uint256 => bytes32) storedBlockHashes;\\n    /// @dev Stored root hashes of L2 -> L1 logs\\n    mapping(uint256 => bytes32) l2LogsRootHashes;\\n    /// @dev Container that stores transactions requested from L1\\n    PriorityQueue.Queue priorityQueue;\\n    /// @dev The smart contract that manages the list with permission to call contract functions\\n    IAllowList allowList;\\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\\n    VerifierParams verifierParams;\\n    /// @notice Bytecode hash of bootloader program.\\n    /// @dev Used as an input to zkp-circuit.\\n    bytes32 l2BootloaderBytecodeHash;\\n    /// @notice Bytecode hash of default account (bytecode for EOA).\\n    /// @dev Used as an input to zkp-circuit.\\n    bytes32 l2DefaultAccountBytecodeHash;\\n    /// @dev Indicates that the porter may be touched on L2 transactions.\\n    /// @dev Used as an input to zkp-circuit.\\n    bool zkPorterIsAvailable;\\n}\\n\",\"keccak256\":\"0x1f516b4ec879df93a4044881f1eb938e3ae250641e83f4f40a06463b0496c09e\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/Verifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/libraries/UncheckedMath.sol\\\";\\nimport \\\"./Plonk4VerifierWithAccessToDNext.sol\\\";\\n\\ncontract Verifier is Plonk4VerifierWithAccessToDNext {\\n    using UncheckedMath for uint256;\\n\\n    function get_verification_key() internal pure returns (VerificationKey memory vk) {\\n        vk.num_inputs = 1;\\n        vk.domain_size = 256;\\n        vk.omega = PairingsBn254.new_fr(0x1058a83d529be585820b96ff0a13f2dbd8675a9e5dd2336a6692cc1e5a526c81);\\n        // coefficients\\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\\n            0x05f5cabc4eab14cfabee1334ef7f33a66259cc9fd07af862308d5c41765adb4b,\\n            0x128a103fbe66c8ff697182c0963d963208b55a5a53ddeab9b4bc09dc2a68a9cc\\n        );\\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\\n            0x0d9980170c334c107e6ce4d66bbc4d23bbcdc97c020b1e1c3f6e04c6c663d2c2,\\n            0x0968205845091ceaf3f863b1613fbdf7ce9a87ccfd97f22011679e6350384419\\n        );\\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\\n            0x0c84a19b149a1612cb042ad86382b9e94367c0add60d07e12399999e7db09efe,\\n            0x1e02f70c44c9bfb7bf2164cee2ab4813bcb9be56eb432e2e9dfffffe196d846d\\n        );\\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\\n            0x1eb3599506a41a7d62e1f7438d6732fbb9d1eda7b9c7a0213eca63c9334ac5a9,\\n            0x23563d9f429908d8ea80bffa642840fb081936d45b388bafc504d9b1e5b1c410\\n        );\\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\\n            0x0000000000000000000000000000000000000000000000000000000000000000,\\n            0x0000000000000000000000000000000000000000000000000000000000000001\\n        );\\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\\n            0x063e8dac7ee3ee6a4569fd53b416fe17f8f10de8c435c336e5a1cf2e02643200,\\n            0x1d4c1781b78f926d55f89ef72abb96bee350ce60ddc684f5a02d87c5f4cdf943\\n        );\\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\\n            0x0000000000000000000000000000000000000000000000000000000000000000,\\n            0x0000000000000000000000000000000000000000000000000000000000000001\\n        );\\n        // gate selectors\\n        vk.gate_selectors_commitments[0] = PairingsBn254.new_g1(\\n            0x0b487eb34c8480ea506f5c6c25857155d61d7f9824b60bc80e1a415a5bcf247f,\\n            0x07ea0d0d0df9dbcc944e9341a5bb49ae796d9dc9d7ca1c032b53784715b946db\\n        );\\n        vk.gate_selectors_commitments[1] = PairingsBn254.new_g1(\\n            0x0fa66faa0b9ea782eb400175ac9f0c05f0de64332eec54a87cd20db4540baec2,\\n            0x07dea33d314c690c4bd4b21deda1a44b9f8dd87e539024622768c2f8b8bdabe1\\n        );\\n        // permutation\\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x120482c52e31d2373f9b2dc80a47e68f035e278d220fa8a89d0c81f133343953,\\n            0x02928a78ea2e1a943e9220b7e288fd48a561263f8e5f94518f21aaa43781ceac\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x1dfad2c4d60704bcf6af0abd9cce09151f063c4b52200c268e470c6a6c93cbca,\\n            0x08b28dd6ca14d7c33e078fe0f332a9a4d95ac8df171355de9e69930aec02b5dc\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x0935a4fd6ab67925929661cf2d2e814f87f589ee6234cb9675ecc2d897f1b338,\\n            0x1032ccc41c047413fce4a847ba7e51e4a2ea406d89a88d480c5f0efaf6c8c89a\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x0eafaea3af7d1fadb2138db1b991af5d2218f6892714fd019898c7e1a43ecfe8,\\n            0x28fb17eda285ed74cc9771d62fad22ab459bbb0a4968c489972aca8b7e618fcb\\n        );\\n        // lookup table commitments\\n        vk.lookup_selector_commitment = PairingsBn254.new_g1(\\n            0x155201a564e721b1f5c06315ad4e24eaad3cbdd6197b19cd903fe85613080f86,\\n            0x12fb201bc896572ac14357e2601f5118636f1eeb7b89c177ac940aac3b5253ec\\n        );\\n        vk.lookup_tables_commitments[0] = PairingsBn254.new_g1(\\n            0x1cb0e2ae4d52743898d94d7f1729bd0d3357ba035cdb6b3af7ebff9159f8f297,\\n            0x15ee595227c9e0f7a487ddb8072d5ea3cfd058bc569211c3546bc0e80051553f\\n        );\\n        vk.lookup_tables_commitments[1] = PairingsBn254.new_g1(\\n            0x13e4ab94c03a5a29719930c1361d854e244cf918f1e29cb031303f4a13b71977,\\n            0x0f792ef4c6c8746c97be61ed9b20f31ba2dec3bd5c91a2d9a4a586f19af3a07c\\n        );\\n        vk.lookup_tables_commitments[2] = PairingsBn254.new_g1(\\n            0x1c9e69bd2b04240ebe44fb23d67c596fce4a1336109fdce38c2f184a63cd8acc,\\n            0x1cbd3e72bdbce827227e503690b10be9365ae760e9d2babde5ba81edf12f8206\\n        );\\n        vk.lookup_tables_commitments[3] = PairingsBn254.new_g1(\\n            0x2a0d46339fbf72104df6a241b53a957602b1a16f6e3b9f89bf3e4c4645df823c,\\n            0x11a601d7b2eee4b7885f34c9873426ba1263f38eae2e0351d653b8b1ba9c67f6\\n        );\\n        vk.lookup_table_type_commitment = PairingsBn254.new_g1(\\n            0x1a70e43f18b18d686807c2b1c6471cd949dd251b48090bca443d86b97afae951,\\n            0x0e6e23ad15a1bd851b228788ae4a03bf25bda39ede6d5a92d501a8402a0dfe43\\n        );\\n        // non residues\\n        vk.non_residues[0] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000005);\\n        vk.non_residues[1] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000007);\\n        vk.non_residues[2] = PairingsBn254.new_fr(0x000000000000000000000000000000000000000000000000000000000000000a);\\n\\n        // g2 elements\\n        vk.g2_elements[0] = PairingsBn254.new_g2(\\n            [\\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n            ],\\n            [\\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n            ]\\n        );\\n        vk.g2_elements[1] = PairingsBn254.new_g2(\\n            [\\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\\n            ],\\n            [\\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\\n            ]\\n        );\\n    }\\n\\n    function deserialize_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\\n        internal\\n        pure\\n        returns (Proof memory proof)\\n    {\\n        // require(serialized_proof.length == 44); TODO\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i = i.uncheckedInc()) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j;\\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\\n            proof.state_polys_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j.uncheckedInc()]\\n            );\\n\\n            j = j.uncheckedAdd(2);\\n        }\\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n\\n        proof.lookup_s_poly_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n\\n        proof.lookup_grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\\n            proof.quotient_poly_parts_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j.uncheckedInc()]\\n            );\\n            j = j.uncheckedAdd(2);\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.state_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n\\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\\n            proof.state_polys_openings_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.gate_selectors_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\\n            proof.copy_permutation_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n            j = j.uncheckedInc();\\n        }\\n        proof.copy_permutation_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_s_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_t_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n\\n        j = j.uncheckedInc();\\n        proof.lookup_t_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_selector_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.lookup_table_type_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.quotient_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.linearization_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\\n        j = j.uncheckedInc();\\n        proof.opening_proof_at_z = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n        j = j.uncheckedAdd(2);\\n        proof.opening_proof_at_z_omega = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j.uncheckedInc()]\\n        );\\n    }\\n\\n    function verify_serialized_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        VerificationKey memory vk = get_verification_key();\\n        require(vk.num_inputs == public_inputs.length);\\n\\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\\n\\n        return verify(proof, vk);\\n    }\\n}\\n\",\"keccak256\":\"0x5d093f2c0d383f12fb6b8c2b2bc32c8ea07f579c2daee7d68aed8cf8041715a0\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\nimport \\\"../libraries/Diamond.sol\\\";\\n\\ninterface IDiamondCut {\\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external;\\n\\n    function cancelDiamondCutProposal() external;\\n\\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external;\\n\\n    function emergencyFreezeDiamond() external;\\n\\n    function unfreezeDiamond() external;\\n\\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external;\\n\\n    // FIXME: token holders should have the ability to cancel the upgrade\\n\\n    event DiamondCutProposal(Diamond.FacetCut[] _facetCuts, address _initAddress);\\n\\n    event DiamondCutProposalCancelation();\\n\\n    event DiamondCutProposalExecution(Diamond.DiamondCutData _diamondCut);\\n\\n    event EmergencyFreeze();\\n\\n    event Unfreeze();\\n\\n    event EmergencyDiamondCutApproved(address _address);\\n}\\n\",\"keccak256\":\"0x75be50498de7a7d1a95493aa066e45ed57f8f10f5176be3744ee03e7d5cc1141\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IExecutor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\ninterface IExecutor {\\n    /// @notice Rollup block stored data\\n    /// @param blockNumber Rollup block number\\n    /// @param blockHash Hash of L2 block\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param priorityOperationsHash Hash of all priority operations from this block\\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\\n    /// @param stateRoot Merkle root of the rollup state tree\\n    /// @param commitment Verified input for the zkSync circuit\\n    struct StoredBlockInfo {\\n        uint64 blockNumber;\\n        bytes32 blockHash;\\n        uint64 indexRepeatedStorageChanges;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 priorityOperationsHash;\\n        bytes32 l2LogsTreeRoot;\\n        uint256 timestamp;\\n        bytes32 commitment;\\n    }\\n\\n    /// @notice Data needed to commit new block\\n    /// @param blockNumber Number of the committed block\\n    /// @param timestamp Unix timestamp denoting the start of the block execution\\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\\n    /// @param newStateRoot The state root of the full state tree\\n    /// @param ergsPerPubdataByteInBlock Price in ergs per one byte of published pubdata in block\\n    /// @param ergsPerCodeDecommittmentWord Price in ergs per decommittment of one machine word from l2 bytecode\\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\\n    /// @param priorityOperationsHash Hash of all priority operations from this block\\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\\n    struct CommitBlockInfo {\\n        uint64 blockNumber;\\n        uint64 timestamp;\\n        uint64 indexRepeatedStorageChanges;\\n        bytes32 newStateRoot;\\n        uint16 ergsPerCodeDecommittmentWord;\\n        uint256 numberOfLayer1Txs;\\n        bytes32 l2LogsTreeRoot;\\n        bytes32 priorityOperationsHash;\\n        bytes initialStorageChanges;\\n        bytes repeatedStorageChanges;\\n        bytes l2Logs;\\n        bytes[] l2ArbitraryLengthMessages;\\n        bytes[] factoryDeps;\\n    }\\n\\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\\n    /// TODO: The verifier integration is not finished yet, change the structure for compatibility later\\n    struct ProofInput {\\n        uint256[] recurisiveAggregationInput;\\n        uint256[] serializedProof;\\n    }\\n\\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\\n        external;\\n\\n    function proveBlocks(\\n        StoredBlockInfo calldata _prevBlock,\\n        StoredBlockInfo[] calldata _committedBlocks,\\n        ProofInput calldata _proof\\n    ) external;\\n\\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\\n\\n    function revertBlocks(uint256 _blocksToRevert) external;\\n\\n    /// @notice Event emitted when a block is committed\\n    event BlockCommit(uint256 indexed blockNumber);\\n\\n    /// @notice Event emitted when a block is executed\\n    event BlockExecution(uint256 indexed blockNumber);\\n\\n    /// @notice Event emitted when blocks are reverted\\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\\n}\\n\",\"keccak256\":\"0xc8a0de30a54c7abc686b4d5f0bf9eaf4733c6ddd5a79880e85be77258ce03a48\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IGetters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\ninterface IGetters {\\n    /*//////////////////////////////////////////////////////////////\\n                            CUSTOM GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getVerifier() external view returns (address);\\n\\n    function getGovernor() external view returns (address);\\n\\n    function getTotalBlocksCommitted() external view returns (uint256);\\n\\n    function getTotalBlocksVerified() external view returns (uint256);\\n\\n    function getTotalBlocksExecuted() external view returns (uint256);\\n\\n    function getTotalPriorityTxs() external view returns (uint256);\\n\\n    function getFirstUnprocessedPriorityTx() external view returns (uint256);\\n\\n    function isValidator(address _address) external view returns (bool);\\n\\n    function l2LogsRootHash(uint32 blockNumber) external view returns (bytes32 hash);\\n\\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool);\\n\\n    function isFacetFreezable(address _facet) external view returns (bool);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            DIAMOND LOUPE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Fa\\u0441et structure compatible with the EIP-2535 diamond loupe\\n    /// @param addr The address of the facet contract\\n    /// @param selectors The NON-sorted array with selectors associated with facet\\n    struct Facet {\\n        address addr;\\n        bytes4[] selectors;\\n    }\\n\\n    function facets() external view returns (Facet[] memory);\\n\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);\\n\\n    function facetAddresses() external view returns (address[] memory facets);\\n\\n    function facetAddress(bytes4 _selector) external view returns (address facet);\\n}\\n\",\"keccak256\":\"0x666d1cafd424c9174d55c6e97a529ae73eecba2c7c4b3387bf260bd0aa53b3bb\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\ninterface IGovernance {\\n    function setPendingGovernor(address _newPendingGovernor) external;\\n\\n    function acceptGovernor() external;\\n\\n    function setValidator(address _validator, bool _active) external;\\n\\n    function setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) external;\\n\\n    function setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) external;\\n\\n    function setPorterAvailability(bool _isPorterAvailable) external;\\n\\n    /// @notice \\u0421hanges to the bytecode that is used in L2 as a bootloader (start program)\\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\\n\\n    /// @notice \\u0421hanges to the bytecode that is used in L2 as a default account\\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\\n\\n    /// @notice Porter availability status changes\\n    event IsPorterAvailableStatusUpdate(bool isPorterAvailable);\\n\\n    /// @notice Validator's status changed\\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\\n\\n    /// @notice pendingGovernor is changed\\n    /// @dev Also emitted when new governor is accepted and in this case, `newPendingGovernor` would be zero address\\n    event NewPendingGovernor(address indexed oldPendingGovernor, address indexed newPendingGovernor);\\n\\n    /// @notice Governor changed\\n    event NewGovernor(address indexed newGovernor);\\n}\\n\",\"keccak256\":\"0xf198e4b73230e5768c32fa3355af1d376c7bfd9ee1b6ab1b3485efbed0eb1d50\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IMailbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\nimport {L2Log, L2Message} from \\\"../Storage.sol\\\";\\nimport \\\"../../common/interfaces/IERC20.sol\\\";\\n\\ninterface IMailbox {\\n    /// @dev Structure that includes all fields of the L2 transaction\\n    /// @dev The hash of this structure is the \\\"canonical L2 transaction hash\\\" and can be used as a unique identifier of a tx\\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\\n    /// @param from The sender's address. `uint256` type for possible address format changes and maintaining backward compatibility\\n    /// @param to The recipient's address. `uint256` type for possible address format changes and maintaining backward compatibility\\n    /// @param ergsLimit Ergs limit on L2 transaction. Analog to the `gasLimit` on an L1 transactions\\n    /// @param ergsPerPubdataByteLimit Maximum number of ergs that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\\n    /// @param maxFeePerErg The absolute maximum sender willing to pay per unit of ergs to get the transaction included in a block. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\\n    /// @param maxPriorityFeePerErg The additional fee that is paid directly to the validator to incentivize them to include the transaction in a block. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\\n    /// @param data The calldata that is transmitted for the transaction call\\n    /// @param signature An abstract set of bytes that are used for transaction authorization\\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\\n    struct L2CanonicalTransaction {\\n        uint256 txType;\\n        uint256 from;\\n        uint256 to;\\n        uint256 ergsLimit;\\n        uint256 ergsPerPubdataByteLimit;\\n        uint256 maxFeePerErg;\\n        uint256 maxPriorityFeePerErg;\\n        uint256 paymaster;\\n        // In the future, we might want to add some\\n        // new fields to the struct. The `txData` struct\\n        // is to be passed to account and any changes to its structure\\n        // would mean a breaking change to these accounts. To prevent this,\\n        // we should keep some fields as \\\"reserved\\\".\\n        // It is also recommended that their length is fixed, since\\n        // it would allow easier proof integration (in case we will need\\n        // some special circuit for preprocessing transactions).\\n        uint256[6] reserved;\\n        bytes data;\\n        bytes signature;\\n        uint256[] factoryDeps;\\n        bytes paymasterInput;\\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\\n        // But it is still here, just in case we want to enable some additional functionality.\\n        bytes reservedDynamic;\\n    }\\n\\n    function proveL2MessageInclusion(\\n        uint256 _blockNumber,\\n        uint256 _index,\\n        L2Message calldata _message,\\n        bytes32[] calldata _proof\\n    ) external view returns (bool);\\n\\n    function proveL2LogInclusion(\\n        uint256 _blockNumber,\\n        uint256 _index,\\n        L2Log memory _log,\\n        bytes32[] calldata _proof\\n    ) external view returns (bool);\\n\\n    function serializeL2Transaction(\\n        uint256 _txId,\\n        uint256 _l2Value,\\n        address _sender,\\n        address _contractAddressL2,\\n        bytes calldata _calldata,\\n        uint256 _ergsLimit,\\n        bytes[] calldata _factoryDeps\\n    ) external pure returns (L2CanonicalTransaction memory);\\n\\n    function requestL2Transaction(\\n        address _contractAddressL2,\\n        uint256 _l2Value,\\n        bytes calldata _calldata,\\n        uint256 _ergsLimit,\\n        bytes[] calldata _factoryDeps\\n    ) external payable returns (bytes32 txHash);\\n\\n    function l2TransactionBaseCost(\\n        uint256 _gasPrice,\\n        uint256 _ergsLimit,\\n        uint32 _calldataLength\\n    ) external view returns (uint256);\\n\\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\\n    /// @param txId Serial number of the priority operation\\n    /// @param txHash keccak256 hash of encoded transaction representation\\n    /// @param expirationBlock Ethereum block number up to which priority request should be processed\\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data. Will be marked as known bytecodes in L2\\n    event NewPriorityRequest(\\n        uint256 txId,\\n        bytes32 txHash,\\n        uint64 expirationBlock,\\n        L2CanonicalTransaction transaction,\\n        bytes[] factoryDeps\\n    );\\n}\\n\",\"keccak256\":\"0xc4ea8c255c5759ea84322b5d43f0a84e9347e287cdd469803f72d534dd5aad0a\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IZkSync.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8;\\n\\nimport \\\"./IMailbox.sol\\\";\\nimport \\\"./IGovernance.sol\\\";\\nimport \\\"./IExecutor.sol\\\";\\nimport \\\"./IDiamondCut.sol\\\";\\nimport \\\"./IGetters.sol\\\";\\n\\ninterface IZkSync is IMailbox, IGovernance, IExecutor, IDiamondCut, IGetters {}\\n\",\"keccak256\":\"0x4a988a586ac54ce45cf065bbe1ed8d19b2b4b75ffae0ff9c9276d8a2a3d16c7d\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/Diamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author Matter Labs\\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\\nlibrary Diamond {\\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\\n    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE = keccak256(\\\"diamond.zksync.init\\\");\\n\\n    /// @dev Storage position of `DiamondStorage` structure.\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    /// @dev Utility struct that contains associated facet & meta information of selector\\n    /// @param facetAddress address of the facet which is connected with selector\\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\\n    /// @param isFreezable denotes whether the selector can be frozen.\\n    struct SelectorToFacet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n        bool isFreezable;\\n    }\\n\\n    /// @dev Utility struct that contains associated selectors & meta information of facet\\n    /// @param selectors list of all selectors that belong to the facet\\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\\n    struct FacetToSelectors {\\n        bytes4[] selectors;\\n        uint16 facetPosition;\\n    }\\n\\n    /// @notice The structure that holds all diamond proxy associated parameters\\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\\n    /// @param selectorToFacet An mapping from selector to the facet address and its' meta information\\n    /// @param facetToSelectors An mapping from facet address to its' selector with meta information\\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\\n    struct DiamondStorage {\\n        mapping(bytes4 => SelectorToFacet) selectorToFacet;\\n        mapping(address => FacetToSelectors) facetToSelectors;\\n        address[] facets;\\n        bool isFrozen;\\n    }\\n\\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            diamondStorage.slot := position\\n        }\\n    }\\n\\n    /// @notice Action on selectors for one facet on a Diamond Cut\\n    enum Action {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    /// @dev Parameters for diamond changes that touch one of the facets\\n    /// @param facet The address of facet that's affected by the cut\\n    /// @param action The action that is made on the facet\\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\\n    /// @param selectors An array of unique selectors that belongs to the facet address\\n    struct FacetCut {\\n        address facet;\\n        Action action;\\n        bool isFreezable;\\n        bytes4[] selectors;\\n    }\\n\\n    /// @dev Structure of the diamond proxy changes\\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\\n    /// @param initAddress The address that's dellegate called after setting up new facet changes\\n    /// @param initCalldata Calldata for the delegete call to `initAddress`\\n    struct DiamondCutData {\\n        FacetCut[] facetCuts;\\n        address initAddress;\\n        bytes initCalldata;\\n    }\\n\\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\\n        address initAddress = _diamondCut.initAddress;\\n        bytes memory initCalldata = _diamondCut.initCalldata;\\n        for (uint256 i = 0; i < facetCuts.length; ++i) {\\n            Action action = facetCuts[i].action;\\n            address facet = facetCuts[i].facet;\\n            bool isFacetFreezable = facetCuts[i].isFreezable;\\n            bytes4[] memory selectors = facetCuts[i].selectors;\\n\\n            require(selectors.length > 0, \\\"B\\\"); // no functions for diamond cut\\n\\n            if (action == Action.Add) {\\n                _addFunctions(facet, selectors, isFacetFreezable);\\n            } else if (action == Action.Replace) {\\n                _replaceFunctions(facet, selectors, isFacetFreezable);\\n            } else if (action == Action.Remove) {\\n                _removeFunctions(facet, selectors);\\n            } else {\\n                revert(\\\"C\\\"); // undefined diamond cut action\\n            }\\n        }\\n\\n        _initializeDiamondCut(initAddress, initCalldata);\\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\\n    }\\n\\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\\n\\n    /// @dev Add new functions to the diamond proxy\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _addFunctions(\\n        address _facet,\\n        bytes4[] memory _selectors,\\n        bool _isFacetFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet != address(0), \\\"G\\\"); // facet with zero address cannot be added\\n\\n        // Add facet to the list of facets if the facet address is new one\\n        _saveFacetIfNew(_facet);\\n\\n        for (uint256 i = 0; i < _selectors.length; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress == address(0), \\\"J\\\"); // facet for this selector already exists\\n\\n            _addOneFunction(_facet, selector, _isFacetFreezable);\\n        }\\n    }\\n\\n    /// @dev Change associated facets to already known function selectors\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _replaceFunctions(\\n        address _facet,\\n        bytes4[] memory _selectors,\\n        bool _isFacetFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet != address(0), \\\"K\\\"); // cannot replace facet with zero address\\n\\n        // Add facet to the list of facets if the facet address is a new one\\n        _saveFacetIfNew(_facet);\\n\\n        for (uint256 i = 0; i < _selectors.length; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress != address(0), \\\"L\\\"); // it is impossible to replace the facet with zero address\\n\\n            _removeOneFunction(oldFacet.facetAddress, selector);\\n            _addOneFunction(_facet, selector, _isFacetFreezable);\\n        }\\n    }\\n\\n    /// @dev Remove association with function and facet\\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        require(_facet == address(0), \\\"a1\\\"); // facet address must be zero\\n\\n        for (uint256 i = 0; i < _selectors.length; ++i) {\\n            bytes4 selector = _selectors[i];\\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\\n            require(oldFacet.facetAddress != address(0), \\\"a2\\\"); // Can't delete a non-existent facet\\n\\n            _removeOneFunction(oldFacet.facetAddress, selector);\\n        }\\n    }\\n\\n    /// @dev Add address to the list of known facets if it is not on the list yet\\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\\n    function _saveFacetIfNew(address _facet) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        uint16 selectorsLength = uint16(ds.facetToSelectors[_facet].selectors.length);\\n        // If there are no selectors associated with facet then save facet as new one\\n        if (selectorsLength == 0) {\\n            ds.facetToSelectors[_facet].facetPosition = uint16(ds.facets.length);\\n            ds.facets.push(_facet);\\n        }\\n    }\\n\\n    /// @dev Add one function to the already known facet\\n    /// NOTE: It is expected but NOT enforced that:\\n    /// - `_facet` is NON-ZERO address\\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\\n    /// - `_selector` is NOT associated by another facet\\n    function _addOneFunction(\\n        address _facet,\\n        bytes4 _selector,\\n        bool _isSelectorFreezable\\n    ) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        uint16 selectorPosition = uint16(ds.facetToSelectors[_facet].selectors.length);\\n        ds.selectorToFacet[_selector] = SelectorToFacet({\\n            facetAddress: _facet,\\n            selectorPosition: selectorPosition,\\n            isFreezable: _isSelectorFreezable\\n        });\\n        ds.facetToSelectors[_facet].selectors.push(_selector);\\n    }\\n\\n    /// @dev Remove one associated function with facet\\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\\n\\n        // If the selector is not at the end of the array then move the last element to the selector position\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\\n\\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacet[lastSelector].selectorPosition = uint16(selectorPosition);\\n        }\\n\\n        // Remove last element from the selectors array\\n        ds.facetToSelectors[_facet].selectors.pop();\\n\\n        // Finally, clean up the association with facet\\n        delete ds.selectorToFacet[_selector];\\n\\n        // If there are no selectors for facet then remove the facet from the list of known facets\\n        if (lastSelectorPosition == 0) {\\n            _removeFacet(_facet);\\n        }\\n    }\\n\\n    /// @dev remove facet from the list of known facets\\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated wih `_facet`\\n    function _removeFacet(address _facet) private {\\n        DiamondStorage storage ds = getDiamondStorage();\\n\\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\\n        uint256 lastFacetPosition = ds.facets.length - 1;\\n\\n        // If the facet is not at the end of the array then move the last element to the facet position\\n        if (facetPosition != lastFacetPosition) {\\n            address lastFacet = ds.facets[lastFacetPosition];\\n\\n            ds.facets[facetPosition] = lastFacet;\\n            ds.facetToSelectors[lastFacet].facetPosition = uint16(facetPosition);\\n        }\\n\\n        // Remove last element from the facets array\\n        ds.facets.pop();\\n    }\\n\\n    /// @dev Delegates call to the initialization address with provided calldata\\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"H\\\"); // Non-empty calldata for zero address\\n        } else {\\n            // Do not check whether `_init` is a contract since later we check that it returns data.\\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\\n            require(success, \\\"I\\\"); // delegatecall failed\\n\\n            // Check that called contract returns magic value to make sure that contract logic\\n            // supposed to be used as diamond cut initializer.\\n            require(data.length == 32 && abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \\\"lp\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfedbcad9963963e9570a972b269e7241b902f029d488b52fbd4e9a2d67bf8e3d\",\"license\":\"MIT\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/PairingsBn254.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod - 2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint256[2] X;\\n        uint256[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    // function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod, \\\"x axis isn't valid\\\");\\n        require(y < q_mod, \\\"y axis isn't valid\\\");\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs, \\\"is not on curve\\\");\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return\\n            G2Point(\\n                [\\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\\n                ],\\n                [\\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n                ]\\n            );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(\\n        G1Point memory p1,\\n        G1Point memory p2,\\n        G1Point memory dest\\n    ) internal view {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\\n        // https://eips.ethereum.org/EIPS/eip-197\\n        // Elliptic curve points are encoded as a Jacobian pair (X, Y) where the point at infinity is encoded as (0, 0)\\n        // TODO\\n        if (p.X == 0 && p.Y == 1) {\\n            p.Y = 0;\\n        }\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(\\n        G1Point memory p,\\n        Fr memory s,\\n        G1Point memory dest\\n    ) internal view {\\n        uint256[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\\n        require(p1.length == p2.length);\\n        uint256 elements = p1.length;\\n        uint256 inputSize = elements * 6;\\n        uint256[] memory input = new uint256[](inputSize);\\n        for (uint256 i = 0; i < elements; ) {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        uint256[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(\\n        G1Point memory a1,\\n        G2Point memory a2,\\n        G1Point memory b1,\\n        G2Point memory b2\\n    ) internal view returns (bool) {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\",\"keccak256\":\"0x0532cd43e648a5236d854c85b47d83e4d4faa86ccb87322de0dcc52f0956ee1d\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/PriorityQueue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\\n/// @param expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\\nstruct PriorityOperation {\\n    bytes32 canonicalTxHash;\\n    uint64 expirationBlock;\\n    uint192 layer2Tip;\\n}\\n\\n/// @author Matter Labs\\n/// @dev The library provides the API to interact with the priority queue container\\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\\nlibrary PriorityQueue {\\n    using PriorityQueue for Queue;\\n\\n    /// @notice Container that stores priority operations\\n    /// @param data The inner mapping that saves priority operation by its index\\n    /// @param head The pointer to the last added priority operation\\n    /// @param tail The pointer to the first unprocessed priority operation\\n    struct Queue {\\n        mapping(uint256 => PriorityOperation) data;\\n        uint256 head;\\n        uint256 tail;\\n    }\\n\\n    /// @return Index of the oldest priority operation that wasn't processed yet\\n    /// @notice Returns zero if and only if no operations were processed from the queue\\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\\n        return _queue.tail;\\n    }\\n\\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\\n        return _queue.head;\\n    }\\n\\n    /// @return The total number of unprocessed priority operations in a priority queue\\n    function getSize(Queue storage _queue) internal view returns (uint256) {\\n        return uint256(_queue.head - _queue.tail);\\n    }\\n\\n    /// @return Whether the priority queue contains no operations\\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\\n        return _queue.head == _queue.tail;\\n    }\\n\\n    /// @notice Add the priority operation to the end of the priority queue\\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\\n        // Save value into the stack to avoid double reading from the storage\\n        uint256 head = _queue.head;\\n\\n        _queue.data[head] = _operation;\\n        _queue.head = head + 1;\\n    }\\n\\n    /// @return The first unprocessed priority operation from the queue\\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\\n        require(!_queue.isEmpty(), \\\"D\\\"); // priority queue is empty\\n\\n        return _queue.data[_queue.tail];\\n    }\\n\\n    /// @notice Remove the first unprocessed priority operation from the queue\\n    /// @return priorityOperation that was popped from the priority queue\\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\\n        require(!_queue.isEmpty(), \\\"s\\\"); // priority queue is empty\\n\\n        // Save value into the stack to avoid double reading from the storage\\n        uint256 tail = _queue.tail;\\n\\n        priorityOperation = _queue.data[tail];\\n        delete _queue.data[tail];\\n        _queue.tail = tail + 1;\\n    }\\n}\\n\",\"keccak256\":\"0x83a6511847a78dee8814414191c013cb67fb863e038bc42e21bbbd2641e9e184\",\"license\":\"MIT OR Apache-2.0\"},\"@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/TranscriptLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PairingsBn254.sol\\\";\\n\\nlibrary TranscriptLib {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\",\"keccak256\":\"0x56cd646af0899ea51be78a046b647578bae59714f5f3e3c85010b278c96bfdcc\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/Connector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnable} from \\\"../../shared/ProposedOwnable.sol\\\";\\nimport {IConnector} from \\\"../interfaces/IConnector.sol\\\";\\n\\n/**\\n * @title Connector\\n * @author Connext Labs, Inc.\\n * @notice This contract has the messaging interface functions used by all connectors.\\n *\\n * @dev This contract stores information about mirror connectors, but can be used as a\\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\\n * will be empty\\n *\\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\\n * or `mirrorGas`\\n */\\nabstract contract Connector is ProposedOwnable, IConnector {\\n  // ========== Custom Errors ===========\\n\\n  error Connector__processMessage_notUsed();\\n\\n  // ============ Events ============\\n\\n  event NewConnector(\\n    uint32 indexed domain,\\n    uint32 indexed mirrorDomain,\\n    address amb,\\n    address rootManager,\\n    address mirrorConnector\\n  );\\n\\n  event MirrorConnectorUpdated(address previous, address current);\\n\\n  // ============ Public Storage ============\\n\\n  /**\\n   * @notice The domain of this Messaging (i.e. Connector) contract.\\n   */\\n  uint32 public immutable DOMAIN;\\n\\n  /**\\n   * @notice Address of the AMB on this domain.\\n   */\\n  address public immutable AMB;\\n\\n  /**\\n   * @notice RootManager contract address.\\n   */\\n  address public immutable ROOT_MANAGER;\\n\\n  /**\\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\\n   */\\n  uint32 public immutable MIRROR_DOMAIN;\\n\\n  /**\\n   * @notice Connector on L2 for L1 connectors, and vice versa.\\n   */\\n  address public mirrorConnector;\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @notice Errors if the msg.sender is not the registered AMB\\n   */\\n  modifier onlyAMB() {\\n    require(msg.sender == AMB, \\\"!AMB\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\\n   */\\n  modifier onlyRootManager() {\\n    // NOTE: RootManager will be zero address for spoke connectors.\\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\\n    require(msg.sender == ROOT_MANAGER, \\\"!rootManager\\\");\\n    _;\\n  }\\n\\n  // ============ Constructor ============\\n\\n  /**\\n   * @notice Creates a new HubConnector instance\\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\\n   * for optimism, there is one connector on optimism and one connector on mainnet)\\n   * @param _domain The domain this connector lives on\\n   * @param _mirrorDomain The spoke domain\\n   * @param _amb The address of the amb on the domain this connector lives on\\n   * @param _rootManager The address of the RootManager on mainnet\\n   * @param _mirrorConnector The address of the spoke connector\\n   */\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector\\n  ) ProposedOwnable() {\\n    // set the owner\\n    _setOwner(msg.sender);\\n\\n    // sanity checks on values\\n    require(_domain != 0, \\\"empty domain\\\");\\n    require(_rootManager != address(0), \\\"empty rootManager\\\");\\n    // see note at top of contract on why the mirror values are not sanity checked\\n\\n    // set immutables\\n    DOMAIN = _domain;\\n    AMB = _amb;\\n    ROOT_MANAGER = _rootManager;\\n    MIRROR_DOMAIN = _mirrorDomain;\\n    // set mutables if defined\\n    if (_mirrorConnector != address(0)) {\\n      _setMirrorConnector(_mirrorConnector);\\n    }\\n\\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\\n  }\\n\\n  // ============ Receivable ============\\n  /**\\n   * @notice Connectors may need to receive native asset to handle fees when sending a\\n   * message\\n   */\\n  receive() external payable {}\\n\\n  // ============ Admin Functions ============\\n\\n  /**\\n   * @notice Sets the address of the l2Connector for this domain\\n   */\\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\\n    _setMirrorConnector(_mirrorConnector);\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Processes a message received by an AMB\\n   * @dev This is called by AMBs to process messages originating from mirror connector\\n   */\\n  function processMessage(bytes memory _data) external virtual onlyAMB {\\n    _processMessage(_data);\\n    emit MessageProcessed(_data, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Checks the cross domain sender for a given address\\n   */\\n  function verifySender(address _expected) external returns (bool) {\\n    return _verifySender(_expected);\\n  }\\n\\n  // ============ Virtual Functions ============\\n\\n  /**\\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\\n   * @param _data The contents of the message\\n   * @param _encodedData Data used to send the message; specific to connector\\n   */\\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\\n\\n  /**\\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\\n   * root generated on the l2 domain.\\n   */\\n  function _processMessage(\\n    bytes memory /* _data */\\n  ) internal virtual {\\n    // By default, reverts. This is to ensure the call path is not used unless this function is\\n    // overridden by the inheriting class\\n    revert Connector__processMessage_notUsed();\\n  }\\n\\n  /**\\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\\n   * is the expected address.\\n   * @dev Should be overridden by the implementing Connector contract.\\n   */\\n  function _verifySender(address _expected) internal virtual returns (bool);\\n\\n  // ============ Private Functions ============\\n\\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\\n    mirrorConnector = _mirrorConnector;\\n  }\\n}\\n\",\"keccak256\":\"0x08d4077a1b5caf9f46491206064bb24bee467dd741b42fed3d30a608eea83368\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/GasCap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnable} from \\\"../../shared/ProposedOwnable.sol\\\";\\n\\nabstract contract GasCap is ProposedOwnable {\\n  // ============ Storage ============\\n  /**\\n   * @notice The gnosis amb requires destination gas to be specified on the origin.\\n   * The gas used will be passed in by the relayer to allow for real-time estimates,\\n   * but will be capped at the admin-set cap.\\n   */\\n  uint256 gasCap;\\n\\n  // ============ Events ============\\n\\n  /**\\n   * @notice Emitted when admin updates the gas cap\\n   * @param _previous The starting value\\n   * @param _updated The final value\\n   */\\n  event GasCapUpdated(uint256 _previous, uint256 _updated);\\n\\n  // ============ Constructor ============\\n  constructor(uint256 _gasCap) {\\n    _setGasCap(_gasCap);\\n  }\\n\\n  // ============ Admin Fns ============\\n  function setGasCap(uint256 _gasCap) public onlyOwner {\\n    _setGasCap(_gasCap);\\n  }\\n\\n  // ============ Internal Fns ============\\n\\n  /**\\n   * @notice Used (by admin) to update the gas cap\\n   * @param _gasCap The new value\\n   */\\n  function _setGasCap(uint256 _gasCap) internal {\\n    emit GasCapUpdated(gasCap, _gasCap);\\n    gasCap = _gasCap;\\n  }\\n\\n  /**\\n   * @notice Used to get the gas to use. Will be the original value IFF it\\n   * is less than the cap\\n   * @param _gas The proposed gas value\\n   */\\n  function _getGas(uint256 _gas) internal view returns (uint256) {\\n    if (_gas > gasCap) {\\n      _gas = gasCap;\\n    }\\n    return _gas;\\n  }\\n}\\n\",\"keccak256\":\"0xb8b52a3372f08490c918d1f490ad80764d54bd62d1638e4d17a5b552efe6587d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/HubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {Connector} from \\\"./Connector.sol\\\";\\n\\n/**\\n * @title HubConnector\\n * @author Connext Labs, Inc.\\n * @notice This contract implements the messaging functions needed on the hub-side of a given AMB.\\n * The HubConnector has a limited set of functionality compared to the SpokeConnector, namely that\\n * it contains no logic to store or prove messages.\\n *\\n * @dev This contract should be deployed on the hub-side of an AMB (i.e. on L1), and contracts\\n * which extend this should implement the virtual functions defined in the BaseConnector class\\n */\\nabstract contract HubConnector is Connector {\\n  /**\\n   * @notice Creates a new HubConnector instance\\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\\n   * for optimism, there is one connector on optimism and one connector on mainnet)\\n   * @param _domain The domain this connector lives on\\n   * @param _mirrorDomain The spoke domain\\n   * @param _amb The address of the amb on the domain this connector lives on\\n   * @param _rootManager The address of the RootManager on mainnet\\n   * @param _mirrorConnector The address of the spoke connector\\n   */\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector\\n  ) Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {}\\n\\n  // ============ Public fns ============\\n  /**\\n   * @notice Sends a message over the amb\\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\\n   */\\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\\n    _sendMessage(_data, _encodedData);\\n    emit MessageSent(_data, _encodedData, msg.sender);\\n  }\\n}\\n\",\"keccak256\":\"0xc35621419ca872ed0550b0943a577b39942f3d2c9b54de008fee382d5ad290e4\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\n// Importing zkSync contract interface\\nimport \\\"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IZkSync.sol\\\";\\n\\nimport {IRootManager} from \\\"../../interfaces/IRootManager.sol\\\";\\nimport {HubConnector} from \\\"../HubConnector.sol\\\";\\nimport {Connector} from \\\"../Connector.sol\\\";\\nimport {GasCap} from \\\"../GasCap.sol\\\";\\n\\ncontract ZkSyncHubConnector is HubConnector, GasCap {\\n  // ============ Storage ============\\n\\n  // NOTE: This is needed because we need to track the roots we've\\n  // already sent across chains. When sending an zkSync message, we send calldata\\n  // for Connector.processMessage. At any point these messages could be processed\\n  // before the timeout using `processFromRoot` or after the timeout using `process`\\n  // we track the roots sent here to ensure we process each root once\\n  mapping(bytes32 => bool) public processed;\\n\\n  // ============ Constructor ============\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector,\\n    uint256 _gasCap\\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) GasCap(_gasCap) {}\\n\\n  // ============ Override Fns ============\\n  function _verifySender(address) internal pure override returns (bool) {\\n    // NOTE: sender from L2 is asserted in the `processMessageFromRoot` function. Cross domain\\n    // sender is packed in with the L2Message struct, so you should not be verifying the\\n    // sender using this method. Always return false.\\n    // See docs here: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\\n    return false;\\n  }\\n\\n  /**\\n   * @dev Sends `aggregateRoot` to messaging on l2\\n   */\\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\\n    // Should include gasPrice value for `l2TransactionBaseCOst` specialized calldata\\n    require(_encodedData.length == 32, \\\"!data length\\\");\\n    // Should always be dispatching the aggregate root\\n    require(_data.length == 32, \\\"!length\\\");\\n    // Get the calldata\\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\\n    // Get the gas data\\n    uint256 gasPrice = abi.decode(_encodedData, (uint256));\\n\\n    // Declare the ergs limit\\n    uint256 ERGS_LIMIT = 10000;\\n\\n    // Get the max supplied\\n    uint256 fee = _getGas(msg.value);\\n\\n    // Ensure it is above minimum\\n    require(fee > IZkSync(AMB).l2TransactionBaseCost(gasPrice, ERGS_LIMIT, uint32(_calldata.length)), \\\"!fees\\\");\\n\\n    // Dispatch message\\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l1-l2.html#structure\\n    // calling L2 smart contract from L1 Example contract\\n    // note: msg.value must be passed in and can be retrieved from the AMB view function `l2TransactionBaseCost`\\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l1-l2.html#using-contract-interface-in-your-project\\n    IZkSync(AMB).requestL2Transaction{value: fee}(\\n      // The address of the L2 contract to call\\n      mirrorConnector,\\n      // We pass no ETH with the call\\n      0,\\n      // Encoding the calldata for the execute\\n      _calldata,\\n      // Ergs limit\\n      ERGS_LIMIT,\\n      // factory dependencies\\n      new bytes[](0)\\n    );\\n  }\\n\\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\\n  // `processMessageFromRoot` flow.\\n\\n  /**\\n   * @notice Processes message and proves inclusion of that message in the root.\\n   *\\n   * @dev modified from: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\\n   */\\n  function processMessageFromRoot(\\n    // zkSync block number in which the message was sent\\n    uint32 _l2BlockNumber,\\n    // Message index, that can be received via API\\n    uint256 _l2MessageIndex,\\n    // The L2 transaction number in a block, in which the log was sent\\n    uint16 _l2TxNumberInBlock,\\n    // The message that was sent from l2\\n    bytes calldata _message,\\n    // Merkle proof for the message\\n    bytes32[] calldata _proof\\n  ) external {\\n    // sanity check root length (32 bytes root)\\n    require(_message.length == 32, \\\"!length\\\");\\n\\n    IZkSync zksync = IZkSync(AMB);\\n    L2Message memory message = L2Message({\\n      txNumberInBlock: _l2TxNumberInBlock,\\n      sender: mirrorConnector,\\n      data: _message\\n    });\\n\\n    bool success = zksync.proveL2MessageInclusion(_l2BlockNumber, _l2MessageIndex, message, _proof);\\n    require(success, \\\"!proven\\\");\\n\\n    bytes32 _root = bytes32(_message);\\n\\n    // NOTE: there are no guarantees the messages are processed once, so processed roots\\n    // must be tracked within the connector. See:\\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\\n    if (!processed[_root]) {\\n      // set root to processed\\n      processed[_root] = true;\\n      // update the root on the root manager\\n      IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, _root);\\n      emit MessageProcessed(_message, msg.sender);\\n    } // otherwise root was already sent to root manager\\n  }\\n}\\n\",\"keccak256\":\"0xc26fcfab4e05cee6a15984df844ff0e7fe020abc5082950ca1c7b8e029df194d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"../../shared/interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This interface is what the Connext contract will send and receive messages through.\\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\\n * could be Nomad or a generic AMB under the hood).\\n *\\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\\n *\\n * Flow from transfer from polygon to optimism:\\n * 1. User calls `xcall` with destination specified\\n * 2. This will swap in to the bridge assets\\n * 3. The swapped assets will get burned\\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\\n *    to the root\\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\\n *    mainnet. This is done on all \\\"spoke\\\" domains.\\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\\n *    root from all of the AMBs\\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\\n *      tree root\\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\\n *    process on the `Connext` contract\\n * 9. Takes minted bridge tokens and credits the LP\\n *\\n * AMB requirements:\\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\\n * - Ability to read *our root* from the AMB\\n *\\n * AMBs:\\n * - PoS bridge from polygon\\n * - arbitrum bridge\\n * - optimism bridge\\n * - gnosis chain\\n * - bsc (use multichain for messaging)\\n */\\ninterface IConnector is IProposedOwnable {\\n  // ============ Events ============\\n  /**\\n   * @notice Emitted whenever a message is successfully sent over an AMB\\n   * @param data The contents of the message\\n   * @param encodedData Data used to send the message; specific to connector\\n   * @param caller Who called the function (sent the message)\\n   */\\n  event MessageSent(bytes data, bytes encodedData, address caller);\\n\\n  /**\\n   * @notice Emitted whenever a message is successfully received over an AMB\\n   * @param data The contents of the message\\n   * @param caller Who called the function\\n   */\\n  event MessageProcessed(bytes data, address caller);\\n\\n  // ============ Public fns ============\\n\\n  function processMessage(bytes memory _data) external;\\n\\n  function verifySender(address _expected) external returns (bool);\\n}\\n\",\"keccak256\":\"0xfba166354b442fa72b05be07aed38400b47f68498e8dfdd94fc43df00c401ed1\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IRootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\ninterface IRootManager {\\n  /**\\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\\n   * spoke domains.\\n   * @dev This must read information for the root from the registered AMBs.\\n   */\\n  function propagate(\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData\\n  ) external payable;\\n\\n  /**\\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\\n   * inbound root.\\n   * @dev This must read information for the root from the registered AMBs\\n   */\\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\\n}\\n\",\"keccak256\":\"0xa895dfaa4baad37a636e7e7e7da72a0a4badfd2d3d8256f975e5101cd5a98236\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/shared/ProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"./interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @title ProposedOwnable\\n * @notice Contract module which provides a basic access control mechanism,\\n * where there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed via a two step process:\\n * 1. Call `proposeOwner`\\n * 2. Wait out the delay period\\n * 3. Call `acceptOwner`\\n *\\n * @dev This module is used through inheritance. It will make available the\\n * modifier `onlyOwner`, which can be applied to your functions to restrict\\n * their use to the owner.\\n *\\n * @dev The majority of this code was taken from the openzeppelin Ownable\\n * contract\\n *\\n */\\nabstract contract ProposedOwnable is IProposedOwnable {\\n  // ========== Custom Errors ===========\\n\\n  error ProposedOwnable__onlyOwner_notOwner();\\n  error ProposedOwnable__onlyProposed_notProposedOwner();\\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n  error ProposedOwnable__renounceOwnership_noProposal();\\n  error ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n  // ============ Properties ============\\n\\n  address private _owner;\\n\\n  address private _proposed;\\n  uint256 private _proposedOwnershipTimestamp;\\n\\n  uint256 private constant _delay = 7 days;\\n\\n  // ======== Getters =========\\n\\n  /**\\n   * @notice Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposed() public view virtual returns (address) {\\n    return _proposed;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposedTimestamp() public view virtual returns (uint256) {\\n    return _proposedOwnershipTimestamp;\\n  }\\n\\n  /**\\n   * @notice Returns the delay period before a new owner can be accepted.\\n   */\\n  function delay() public view virtual returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the proposed owner.\\n   */\\n  modifier onlyProposed() {\\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if the ownership delay has not elapsed\\n   */\\n  modifier ownershipDelayElapsed() {\\n    // Ensure delay has elapsed\\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Indicates if the ownership has been renounced() by\\n   * checking if current owner is address(0)\\n   */\\n  function renounced() public view returns (bool) {\\n    return _owner == address(0);\\n  }\\n\\n  // ======== External =========\\n\\n  /**\\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\\n   * newly proposed owner as step 1 in a 2-step process\\n   */\\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\\n    // Contract as source of truth\\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\\n\\n    // Sanity check: reasonable proposal\\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n\\n    _setProposed(newlyProposed);\\n  }\\n\\n  /**\\n   * @notice Renounces ownership of the contract after a delay\\n   */\\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\\n    // Ensure there has been a proposal cycle started\\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\\n\\n    // Require proposed is set to 0\\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(address(0));\\n  }\\n\\n  /**\\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\\n    // is 0-d out and this check is implicitly enforced by modifier\\n\\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\\n    // the only time this would happen is if the _proposed was never\\n    // set (will fail from modifier) or if the owner == _proposed (checked\\n    // above)\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(_proposed);\\n  }\\n\\n  // ======== Internal =========\\n\\n  function _setOwner(address newOwner) internal {\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n    delete _proposedOwnershipTimestamp;\\n    delete _proposed;\\n  }\\n\\n  function _setProposed(address newlyProposed) private {\\n    _proposedOwnershipTimestamp = block.timestamp;\\n    _proposed = newlyProposed;\\n    emit OwnershipProposed(newlyProposed);\\n  }\\n}\\n\",\"keccak256\":\"0xa96eff4fdff55ffa29cda5c18285a9af04c3cbaf55f83696085cdd2251a8d6c0\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IProposedOwnable\\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\\n * process\\n */\\ninterface IProposedOwnable {\\n  /**\\n   * @dev This emits when change in ownership of a contract is proposed.\\n   */\\n  event OwnershipProposed(address indexed proposedOwner);\\n\\n  /**\\n   * @dev This emits when ownership of a contract changes.\\n   */\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @notice Get the address of the owner\\n   * @return owner_ The address of the owner.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   * @notice Get the address of the proposed owner\\n   * @return proposed_ The address of the proposed.\\n   */\\n  function proposed() external view returns (address proposed_);\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   * @param newlyProposed The proposed new owner of the contract\\n   */\\n  function proposeNewOwner(address newlyProposed) external;\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   */\\n  function acceptProposedOwner() external;\\n}\\n\",\"keccak256\":\"0x4ec1aa589d37d0c1eac9966e26d2d3540d1661b81763e678f14d2c6fa0682323\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101006040523480156200001257600080fd5b50604051620017d1380380620017d18339810160408190526200003591620002db565b80868686868684848484846200004b336200019a565b8463ffffffff16600003620000965760405162461bcd60e51b815260206004820152600c60248201526b32b6b83a3c903237b6b0b4b760a11b60448201526064015b60405180910390fd5b6001600160a01b038216620000e25760405162461bcd60e51b815260206004820152601160248201527032b6b83a3c903937b7ba26b0b730b3b2b960791b60448201526064016200008d565b63ffffffff8086166080526001600160a01b0380851660a05283811660c05290851660e0528116156200011a576200011a81620001ff565b604080516001600160a01b0385811682528481166020830152831681830152905163ffffffff86811692908816917f4f9c27c2fe3f84576ea469d367d044da53c45e951617e8389f2b5ed8db9d25f09181900360600190a3505050505050505050506200018d816200026860201b60201c565b5050505050505062000353565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b805163ffffffff81168114620002be57600080fd5b919050565b80516001600160a01b0381168114620002be57600080fd5b60008060008060008060c08789031215620002f557600080fd5b6200030087620002a9565b95506200031060208801620002a9565b94506200032060408801620002c3565b93506200033060608801620002c3565b92506200034060808801620002c3565b915060a087015190509295509295509295565b60805160a05160c05160e051611413620003be60003960008181610141015261096d0152600081816102370152818161042b01526109a80152600081816103be015281816104e00152818161082801528181610b6d0152610c23015260006101e301526114136000f3fe6080604052600436106101235760003560e01c80638da5cb5b116100a0578063d1851c9211610064578063d1851c921461036f578063d232c2201461038d578063d69f9d61146103ac578063db1b7659146103e0578063e92a492f1461040057600080fd5b80638da5cb5b146102bc578063b1f8100d146102da578063c1f0808a146102fa578063c5b350df1461033a578063cc3942831461034f57600080fd5b80635bd11efc116100e75780635bd11efc146102055780635f61e3ec146102255780636a42b8f814610271578063715018a6146102875780637850b0201461029c57600080fd5b8063141684161461012f5780633cf52ffb1461017d57806348e6fa231461019c5780634ff746f6146101b157806352a9674b146101d157600080fd5b3661012a57005b600080fd5b34801561013b57600080fd5b506101637f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff90911681526020015b60405180910390f35b34801561018957600080fd5b506002545b604051908152602001610174565b6101af6101aa366004610f22565b610420565b005b3480156101bd57600080fd5b506101af6101cc366004610f86565b6104d5565b3480156101dd57600080fd5b506101637f000000000000000000000000000000000000000000000000000000000000000081565b34801561021157600080fd5b506101af610220366004610fc3565b61057b565b34801561023157600080fd5b506102597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610174565b34801561027d57600080fd5b5062093a8061018e565b34801561029357600080fd5b506101af6105b2565b3480156102a857600080fd5b506101af6102b7366004610ff3565b610666565b3480156102c857600080fd5b506000546001600160a01b0316610259565b3480156102e657600080fd5b506101af6102f5366004610fc3565b61069a565b34801561030657600080fd5b5061032a610315366004610ff3565b60056020526000908152604090205460ff1681565b6040519015158152602001610174565b34801561034657600080fd5b506101af610738565b34801561035b57600080fd5b50600354610259906001600160a01b031681565b34801561037b57600080fd5b506001546001600160a01b0316610259565b34801561039957600080fd5b506000546001600160a01b03161561032a565b3480156103b857600080fd5b506102597f000000000000000000000000000000000000000000000000000000000000000081565b3480156103ec57600080fd5b5061032a6103fb366004610fc3565b6107a8565b34801561040c57600080fd5b506101af61041b36600461109a565b6107b2565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461048c5760405162461bcd60e51b815260206004820152600c60248201526b10b937b7ba26b0b730b3b2b960a11b60448201526064015b60405180910390fd5b6104968282610a4d565b7fdcaa37a042a0087de79018c629bbd29cee82ca80bd9be394e1696bf9e93550778282336040516104c99392919061118f565b60405180910390a15050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105365760405162461bcd60e51b81526004016104839060208082526004908201526310a0a6a160e11b604082015260600190565b61053f81610cf3565b7fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced81336040516105709291906111cd565b60405180910390a150565b6000546001600160a01b031633146105a6576040516311a8a1bb60e31b815260040160405180910390fd5b6105af81610d0c565b50565b6000546001600160a01b031633146105dd576040516311a8a1bb60e31b815260040160405180910390fd5b62093a80600254426105ef91906111f7565b1161060d576040516324e0285f60e21b815260040160405180910390fd5b60025460000361063057604051630e4b303f60e21b815260040160405180910390fd5b6001546001600160a01b03161561065a576040516323295ef960e01b815260040160405180910390fd5b6106646000610d75565b565b6000546001600160a01b03163314610691576040516311a8a1bb60e31b815260040160405180910390fd5b6105af81610dda565b6000546001600160a01b031633146106c5576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b0382811691161480156106e3575060025415155b15610701576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361072f57604051634a2fb73f60e11b815260040160405180910390fd5b6105af81610e1b565b6001546001600160a01b03163314610763576040516311a7f27160e11b815260040160405180910390fd5b62093a806002544261077591906111f7565b11610793576040516324e0285f60e21b815260040160405180910390fd5b600154610664906001600160a01b0316610d75565b6000805b92915050565b602083146107ec5760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610483565b6040805160608101825261ffff871681526003546001600160a01b03166020808301919091528251601f870182900482028101820184528681527f0000000000000000000000000000000000000000000000000000000000000000936000939290830191908990899081908401838280828437600092018290525093909452505060405163e4948f4360e01b8152929350916001600160a01b038516915063e4948f43906108a6908d908d9087908b908b90600401611218565b602060405180830381865afa1580156108c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108e791906112a1565b9050806109205760405162461bcd60e51b815260206004820152600760248201526610b83937bb32b760c91b6044820152606401610483565b600061092c87896112c3565b60008181526005602052604090205490915060ff16610a405760008181526005602052604090819020805460ff191660011790555163473ec9fd60e11b81527f000000000000000000000000000000000000000000000000000000000000000063ffffffff166004820152602481018290526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638e7d93fa90604401600060405180830381600087803b1580156109ec57600080fd5b505af1158015610a00573d6000803e3d6000fd5b505050507fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced888833604051610a37939291906112e1565b60405180910390a15b5050505050505050505050565b8051602014610a8d5760405162461bcd60e51b815260206004820152600c60248201526b042c8c2e8c240d8cadccee8d60a31b6044820152606401610483565b8151602014610ac85760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610483565b6000634ff746f660e01b83604051602401610ae39190611322565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050600082806020019051810190610b2e9190611335565b90506127106000610b3e34610e69565b8451604051632e6b3b8f60e11b8152600481018690526024810185905263ffffffff90911660448201529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635cd6771e90606401602060405180830381865afa158015610bbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be09190611335565b8111610c165760405162461bcd60e51b8152602060048201526005602482015264216665657360d81b6044820152606401610483565b6003546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163725ad850918491166000888782604051908082528060200260200182016040528015610c8657816020015b6060815260200190600190039081610c715790505b506040518763ffffffff1660e01b8152600401610ca795949392919061134e565b60206040518083038185885af1158015610cc5573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610cea9190611335565b50505050505050565b6040516316c2fdb560e21b815260040160405180910390fd5b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b6000600454821115610e7b5760045491505b5090565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610ea657600080fd5b813567ffffffffffffffff80821115610ec157610ec1610e7f565b604051601f8301601f19908116603f01168101908282118183101715610ee957610ee9610e7f565b81604052838152866020858801011115610f0257600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610f3557600080fd5b823567ffffffffffffffff80821115610f4d57600080fd5b610f5986838701610e95565b93506020850135915080821115610f6f57600080fd5b50610f7c85828601610e95565b9150509250929050565b600060208284031215610f9857600080fd5b813567ffffffffffffffff811115610faf57600080fd5b610fbb84828501610e95565b949350505050565b600060208284031215610fd557600080fd5b81356001600160a01b0381168114610fec57600080fd5b9392505050565b60006020828403121561100557600080fd5b5035919050565b60008083601f84011261101e57600080fd5b50813567ffffffffffffffff81111561103657600080fd5b60208301915083602082850101111561104e57600080fd5b9250929050565b60008083601f84011261106757600080fd5b50813567ffffffffffffffff81111561107f57600080fd5b6020830191508360208260051b850101111561104e57600080fd5b600080600080600080600060a0888a0312156110b557600080fd5b873563ffffffff811681146110c957600080fd5b965060208801359550604088013561ffff811681146110e757600080fd5b9450606088013567ffffffffffffffff8082111561110457600080fd5b6111108b838c0161100c565b909650945060808a013591508082111561112957600080fd5b506111368a828b01611055565b989b979a50959850939692959293505050565b6000815180845260005b8181101561116f57602081850181015186830182015201611153565b506000602082860101526020601f19601f83011685010191505092915050565b6060815260006111a26060830186611149565b82810360208401526111b48186611149565b91505060018060a01b0383166040830152949350505050565b6040815260006111e06040830185611149565b905060018060a01b03831660208301529392505050565b818103818111156107ac57634e487b7160e01b600052601160045260246000fd5b63ffffffff861681528460208201526080604082015261ffff845116608082015260018060a01b0360208501511660a082015260006040850151606060c084015261126660e0840182611149565b838103606085015284815290506001600160fb1b0384111561128757600080fd5b8360051b8086602084013701602001979650505050505050565b6000602082840312156112b357600080fd5b81518015158114610fec57600080fd5b803560208310156107ac57600019602084900360031b1b1692915050565b6040815282604082015282846060830137600060608483018101919091526001600160a01b03929092166020820152601f909201601f191690910101919050565b602081526000610fec6020830184611149565b60006020828403121561134757600080fd5b5051919050565b60018060a01b038616815260006020868184015260a0604084015261137660a0840187611149565b85606085015283810360808501528085518083528383019150838160051b84010184880160005b838110156113cb57601f198684030185526113b9838351611149565b9487019492509086019060010161139d565b50909c9b50505050505050505050505056fea26469706673582212207ab18fe76b7bcabd3fea0677a5d30c639519e5da4b947834bf1bb8bc81c19f3c64736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106101235760003560e01c80638da5cb5b116100a0578063d1851c9211610064578063d1851c921461036f578063d232c2201461038d578063d69f9d61146103ac578063db1b7659146103e0578063e92a492f1461040057600080fd5b80638da5cb5b146102bc578063b1f8100d146102da578063c1f0808a146102fa578063c5b350df1461033a578063cc3942831461034f57600080fd5b80635bd11efc116100e75780635bd11efc146102055780635f61e3ec146102255780636a42b8f814610271578063715018a6146102875780637850b0201461029c57600080fd5b8063141684161461012f5780633cf52ffb1461017d57806348e6fa231461019c5780634ff746f6146101b157806352a9674b146101d157600080fd5b3661012a57005b600080fd5b34801561013b57600080fd5b506101637f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff90911681526020015b60405180910390f35b34801561018957600080fd5b506002545b604051908152602001610174565b6101af6101aa366004610f22565b610420565b005b3480156101bd57600080fd5b506101af6101cc366004610f86565b6104d5565b3480156101dd57600080fd5b506101637f000000000000000000000000000000000000000000000000000000000000000081565b34801561021157600080fd5b506101af610220366004610fc3565b61057b565b34801561023157600080fd5b506102597f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610174565b34801561027d57600080fd5b5062093a8061018e565b34801561029357600080fd5b506101af6105b2565b3480156102a857600080fd5b506101af6102b7366004610ff3565b610666565b3480156102c857600080fd5b506000546001600160a01b0316610259565b3480156102e657600080fd5b506101af6102f5366004610fc3565b61069a565b34801561030657600080fd5b5061032a610315366004610ff3565b60056020526000908152604090205460ff1681565b6040519015158152602001610174565b34801561034657600080fd5b506101af610738565b34801561035b57600080fd5b50600354610259906001600160a01b031681565b34801561037b57600080fd5b506001546001600160a01b0316610259565b34801561039957600080fd5b506000546001600160a01b03161561032a565b3480156103b857600080fd5b506102597f000000000000000000000000000000000000000000000000000000000000000081565b3480156103ec57600080fd5b5061032a6103fb366004610fc3565b6107a8565b34801561040c57600080fd5b506101af61041b36600461109a565b6107b2565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461048c5760405162461bcd60e51b815260206004820152600c60248201526b10b937b7ba26b0b730b3b2b960a11b60448201526064015b60405180910390fd5b6104968282610a4d565b7fdcaa37a042a0087de79018c629bbd29cee82ca80bd9be394e1696bf9e93550778282336040516104c99392919061118f565b60405180910390a15050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105365760405162461bcd60e51b81526004016104839060208082526004908201526310a0a6a160e11b604082015260600190565b61053f81610cf3565b7fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced81336040516105709291906111cd565b60405180910390a150565b6000546001600160a01b031633146105a6576040516311a8a1bb60e31b815260040160405180910390fd5b6105af81610d0c565b50565b6000546001600160a01b031633146105dd576040516311a8a1bb60e31b815260040160405180910390fd5b62093a80600254426105ef91906111f7565b1161060d576040516324e0285f60e21b815260040160405180910390fd5b60025460000361063057604051630e4b303f60e21b815260040160405180910390fd5b6001546001600160a01b03161561065a576040516323295ef960e01b815260040160405180910390fd5b6106646000610d75565b565b6000546001600160a01b03163314610691576040516311a8a1bb60e31b815260040160405180910390fd5b6105af81610dda565b6000546001600160a01b031633146106c5576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b0382811691161480156106e3575060025415155b15610701576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361072f57604051634a2fb73f60e11b815260040160405180910390fd5b6105af81610e1b565b6001546001600160a01b03163314610763576040516311a7f27160e11b815260040160405180910390fd5b62093a806002544261077591906111f7565b11610793576040516324e0285f60e21b815260040160405180910390fd5b600154610664906001600160a01b0316610d75565b6000805b92915050565b602083146107ec5760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610483565b6040805160608101825261ffff871681526003546001600160a01b03166020808301919091528251601f870182900482028101820184528681527f0000000000000000000000000000000000000000000000000000000000000000936000939290830191908990899081908401838280828437600092018290525093909452505060405163e4948f4360e01b8152929350916001600160a01b038516915063e4948f43906108a6908d908d9087908b908b90600401611218565b602060405180830381865afa1580156108c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108e791906112a1565b9050806109205760405162461bcd60e51b815260206004820152600760248201526610b83937bb32b760c91b6044820152606401610483565b600061092c87896112c3565b60008181526005602052604090205490915060ff16610a405760008181526005602052604090819020805460ff191660011790555163473ec9fd60e11b81527f000000000000000000000000000000000000000000000000000000000000000063ffffffff166004820152602481018290526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638e7d93fa90604401600060405180830381600087803b1580156109ec57600080fd5b505af1158015610a00573d6000803e3d6000fd5b505050507fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced888833604051610a37939291906112e1565b60405180910390a15b5050505050505050505050565b8051602014610a8d5760405162461bcd60e51b815260206004820152600c60248201526b042c8c2e8c240d8cadccee8d60a31b6044820152606401610483565b8151602014610ac85760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610483565b6000634ff746f660e01b83604051602401610ae39190611322565b604051602081830303815290604052906001600160e01b0319166020820180516001600160e01b0383818316178352505050509050600082806020019051810190610b2e9190611335565b90506127106000610b3e34610e69565b8451604051632e6b3b8f60e11b8152600481018690526024810185905263ffffffff90911660448201529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635cd6771e90606401602060405180830381865afa158015610bbc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610be09190611335565b8111610c165760405162461bcd60e51b8152602060048201526005602482015264216665657360d81b6044820152606401610483565b6003546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081169163725ad850918491166000888782604051908082528060200260200182016040528015610c8657816020015b6060815260200190600190039081610c715790505b506040518763ffffffff1660e01b8152600401610ca795949392919061134e565b60206040518083038185885af1158015610cc5573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610cea9190611335565b50505050505050565b6040516316c2fdb560e21b815260040160405180910390fd5b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b6000600454821115610e7b5760045491505b5090565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610ea657600080fd5b813567ffffffffffffffff80821115610ec157610ec1610e7f565b604051601f8301601f19908116603f01168101908282118183101715610ee957610ee9610e7f565b81604052838152866020858801011115610f0257600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215610f3557600080fd5b823567ffffffffffffffff80821115610f4d57600080fd5b610f5986838701610e95565b93506020850135915080821115610f6f57600080fd5b50610f7c85828601610e95565b9150509250929050565b600060208284031215610f9857600080fd5b813567ffffffffffffffff811115610faf57600080fd5b610fbb84828501610e95565b949350505050565b600060208284031215610fd557600080fd5b81356001600160a01b0381168114610fec57600080fd5b9392505050565b60006020828403121561100557600080fd5b5035919050565b60008083601f84011261101e57600080fd5b50813567ffffffffffffffff81111561103657600080fd5b60208301915083602082850101111561104e57600080fd5b9250929050565b60008083601f84011261106757600080fd5b50813567ffffffffffffffff81111561107f57600080fd5b6020830191508360208260051b850101111561104e57600080fd5b600080600080600080600060a0888a0312156110b557600080fd5b873563ffffffff811681146110c957600080fd5b965060208801359550604088013561ffff811681146110e757600080fd5b9450606088013567ffffffffffffffff8082111561110457600080fd5b6111108b838c0161100c565b909650945060808a013591508082111561112957600080fd5b506111368a828b01611055565b989b979a50959850939692959293505050565b6000815180845260005b8181101561116f57602081850181015186830182015201611153565b506000602082860101526020601f19601f83011685010191505092915050565b6060815260006111a26060830186611149565b82810360208401526111b48186611149565b91505060018060a01b0383166040830152949350505050565b6040815260006111e06040830185611149565b905060018060a01b03831660208301529392505050565b818103818111156107ac57634e487b7160e01b600052601160045260246000fd5b63ffffffff861681528460208201526080604082015261ffff845116608082015260018060a01b0360208501511660a082015260006040850151606060c084015261126660e0840182611149565b838103606085015284815290506001600160fb1b0384111561128757600080fd5b8360051b8086602084013701602001979650505050505050565b6000602082840312156112b357600080fd5b81518015158114610fec57600080fd5b803560208310156107ac57600019602084900360031b1b1692915050565b6040815282604082015282846060830137600060608483018101919091526001600160a01b03929092166020820152601f909201601f191690910101919050565b602081526000610fec6020830184611149565b60006020828403121561134757600080fd5b5051919050565b60018060a01b038616815260006020868184015260a0604084015261137660a0840187611149565b85606085015283810360808501528085518083528383019150838160051b84010184880160005b838110156113cb57601f198684030185526113b9838351611149565b9487019492509086019060010161139d565b50909c9b50505050505050505050505056fea26469706673582212207ab18fe76b7bcabd3fea0677a5d30c639519e5da4b947834bf1bb8bc81c19f3c64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "processMessage(bytes)": {
        "details": "This is called by AMBs to process messages originating from mirror connector"
      },
      "processMessageFromRoot(uint32,uint256,uint16,bytes,bytes32[])": {
        "details": "modified from: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block"
      },
      "sendMessage(bytes,bytes)": {
        "details": "This is called by the root manager *only* on mainnet to propagate the aggregate root"
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "GasCapUpdated(uint256,uint256)": {
        "notice": "Emitted when admin updates the gas cap"
      },
      "MessageProcessed(bytes,address)": {
        "notice": "Emitted whenever a message is successfully received over an AMB"
      },
      "MessageSent(bytes,bytes,address)": {
        "notice": "Emitted whenever a message is successfully sent over an AMB"
      }
    },
    "kind": "user",
    "methods": {
      "AMB()": {
        "notice": "Address of the AMB on this domain."
      },
      "DOMAIN()": {
        "notice": "The domain of this Messaging (i.e. Connector) contract."
      },
      "MIRROR_DOMAIN()": {
        "notice": "The domain of the corresponding messaging (i.e. Connector) contract."
      },
      "ROOT_MANAGER()": {
        "notice": "RootManager contract address."
      },
      "acceptProposedOwner()": {
        "notice": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "delay()": {
        "notice": "Returns the delay period before a new owner can be accepted."
      },
      "mirrorConnector()": {
        "notice": "Connector on L2 for L1 connectors, and vice versa."
      },
      "owner()": {
        "notice": "Returns the address of the current owner."
      },
      "processMessage(bytes)": {
        "notice": "Processes a message received by an AMB"
      },
      "processMessageFromRoot(uint32,uint256,uint16,bytes,bytes32[])": {
        "notice": "Processes message and proves inclusion of that message in the root."
      },
      "proposeNewOwner(address)": {
        "notice": "Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process"
      },
      "proposed()": {
        "notice": "Returns the address of the proposed owner."
      },
      "proposedTimestamp()": {
        "notice": "Returns the address of the proposed owner."
      },
      "renounceOwnership()": {
        "notice": "Renounces ownership of the contract after a delay"
      },
      "renounced()": {
        "notice": "Indicates if the ownership has been renounced() by checking if current owner is address(0)"
      },
      "sendMessage(bytes,bytes)": {
        "notice": "Sends a message over the amb"
      },
      "setMirrorConnector(address)": {
        "notice": "Sets the address of the l2Connector for this domain"
      },
      "verifySender(address)": {
        "notice": "Checks the cross domain sender for a given address"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8017,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 8019,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "_proposed",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 8021,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "_proposedOwnershipTimestamp",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 7376,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "mirrorConnector",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 7578,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "gasCap",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 7716,
        "contract": "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol:ZkSyncHubConnector",
        "label": "processed",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_bytes32,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}